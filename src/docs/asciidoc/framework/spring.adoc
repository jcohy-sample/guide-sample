[[java-framework-spring-spring]]
= Spring

[[java-framework-spring-1]]
== 选择使用 Spring 框架的原因(Spring 框架为企业级开发带来的好处有哪些)？

可以从以下几个方面作答:

* 非侵入式:支持基于 POJO 的编程模式,不强制性的要求实现 Spring 框架中的接口或继承 Spring 框架中的类.
* IoC 容器:IoC 容器帮助应用程序管理对象以及对象之间的依赖关系,对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码,因为代码的修改可能意味着项目的重新构建和完整的回归测试.有了 IoC 容器,程序员再也不需要自己编写工厂、单例,这一
点特别符合 Spring 的精神"不要重复的发明轮子".
* AOP(面向切面编程):将所有的横切关注功能封装到切面(aspect)中,通过配置的方式将横切关注功能动态添加到目标代码上,进一步实现了业
务逻辑和系统服务之间的分离.另一方面,有了 AOP 程序员可以省去很多自己写代理类的工作.
* MVC:Spring的 MVC 框架是非常优秀的,从各个方面都可以甩 Struts 2 几条街,为 Web 表示层提供了更好的解决方案.
* 事务管理:Spring 以宽广的胸怀接纳多种持久层技术,并且为其提供了声明式的事务管理,在不需要任何一行代码的情况下就能够完成事务管理.
* 其他:选择 Spring 框架的原因还远不止于此,Spring 为 Java 企业级开发提供了一站式选择,你可以在需要的时候使用它的部分和全部,更重要的是,你甚至可以在感觉不到 Spring 存在的情况下,在你的项目中使用 Spring 提供的各种优秀的功能.

[[java-framework-spring-2]]
== 什么是 IoC 和 DI？DI 是如何实现的？

IoC 叫控制反转,是 Inversion of Control 的缩写,DI(Dependency Injection)叫依赖注入,是对 IoC 更简单的诠释.控制反转是把传统上由程序代码直接操控的对象的调用权交给容器,通过容器来实现对象组件的装配和管理.
所谓的"控制反转"就是对组件对象控制权的转移,从程序代码本身转移到了外部容器,由容器来创建对象并管理对象之间的依赖关系.IoC 体现了好莱坞原则- "Don’t call me, we will call you".依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象.配置对象的工作应该由容器负责,
查找资源的逻辑应该从应用组件的代码中抽取出来,交给容器来完成.DI 是对 IoC 更准确的描述,即组件之间的依赖关系由容器在运行期决定,形象的来说,即由容器动态的将某种依赖关系注入到组件之中.

举个例子:一个类 A 需要用到接口 B 中的方法,那么就需要为类 A 和接口 B 建立关联或依赖关系,最原始的方法是在类 A 中创建一个接口 B 的实现类 C 的实例,但这种方法需要开发人员自行维护二者的依赖关系,也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。
如果通过一个容器来管理这些对象以及对象的依赖关系,则只需要在类 A 中定义好用于关联接口 B 的方法(构造器或 setter 方法),将类 A 和接口 B 的实现类 C 放入容器中,通过对容器的配置来实现二者的关联。

依赖注入可以通过 setter 方法注入(设值注入)、构造器注入和接口注入三种方式来实现,Spring 支持 setter 注入和构造器注入,通常使用构造器注入来注入必须的依赖关系,对于可选
的依赖关系,则 setter 注入是更好的选择,setter 注入需要类提供无参构造器或者无参的静态工厂方法来创建对象.

[[java-framework-spring-3]]
== 依赖注入时如何注入集合属性？

可以在定义 Bean 属性时,通过 `<list>/<set>/<map>/<props>` 分别为其注入列表、集合、映射和键值都是字符串的映射属性.

[[java-framework-spring-11]]
== 如何在 Web 项目中配置 Spring 的 IoC 容器？

如果需要在 Web 项目中使用 Spring 的 IoC 容器,可以在 Web 项目配置文件 `web.xml` 中做出如下配置:

[source,xml]
----
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:applicationContext.xml</param-value>
</context-param>
<listener>
    <listener-class>
        org.springframework.web.context.ContextLoaderListener
    </listener-class>
</listener>
----

[[java-framework-spring-12]]
== 在 Web 项目中如何获得 Spring 的 IoC 容器？

[source,java]
----
WebApplicationContext ctx =
    WebApplicationContextUtils.getWebApplicationContext(servletContext);
----

[[java-framework-spring-13]]
== 如何在 Web 项目中配置 Spring MVC？

要使用 Spring MVC 需要在 Web 项目配置文件中配置其前端控制器 `DispatcherServlet`,如下所示:

[source,xml]
----
<web-app>
    <servlet>
        <servlet-name>example</servlet-name>
        <servlet-class>
            org.springframework.web.servlet.DispatcherServlet
        </servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>example</servlet-name>
        <url-pattern>*.html</url-pattern>
    </servlet-mapping>
</web-app>

----

说明:上面的配置中使用了 `*.html` 的后缀映射,这样做一方面不能够通过 URL 推断采用了何种服务器端的技术,另一方面可以欺骗搜索引擎,因为搜索引擎不会搜索动态页面,这种做法称为伪静态化.

[[java-framework-spring-14]]
== 如何在 Spring IoC 容器中配置数据源？

DBCP配置:

[source,xml]
----
<bean id="dataSource"
class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
<property name="driverClassName" value="${jdbc.driverClassName}"/>
<property name="url" value="${jdbc.url}"/>
<property name="username" value="${jdbc.username}"/>
<property name="password" value="${jdbc.password}"/>
</bean>
<context:property-placeholder location="jdbc.properties"/>
----

C3P0 配置:

[source,xml]
----
<bean id="dataSource"
class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close">
<property name="driverClass" value="${jdbc.driverClassName}"/>
<property name="jdbcUrl" value="${jdbc.url}"/>
<property name="user" value="${jdbc.username}"/>
<property name="password" value="${jdbc.password}"/>
</bean>
<context:property-placeholder location="jdbc.properties"/>
----


提示: DBCP 的详细配置在第 153 题中已经完整的展示过了.


[[java-framework-spring-21]]
== Spring 运行原理

. 内部最核心的就是 IOC 了,之前是 new 对象,现在可以直接从容器中获取, 动态注入,这其实就是利用java里的反射.反射其实就是在运行时动态的去创建、调用对象,Spring 就是在运行时,根据 xml Spring 的配置文件来动态的创建对象,和调用对象里的方法的.
. Spring 另一个核心就是AOP面向切面编程,可以为某一类对象 进行监督和控制(也就是在调用这类对象的具体方法的前后去调用你指定的 模块)从而达到对一个模块扩充的功能.这些都是通过配置类达到的.(日志、事务等)
. Spring 目的:就是让对象与对象(模块与模块)之间的关系没有通过代码来关联,都是通过配置类说明 管理的(Spring 根据这些配置 内部通过反射去动态的组装对象)要记住:Spring 是一个容器,凡是在容器里的对象才会有Spring所提供的这些服务和功能.
. Spring 里用的最经典设计模式:模板方法模式.(有兴趣同学可以了解一下) 、核心容器组件是 BeanFactory,它是工厂模式的实现.BeanFactory 使用控制反转(IOC)模式将应用程序的配置和依赖性规范与实际的应用程序代码分开.

[[java-framework-spring-22]]
== Spring MVC 的工作原理是怎样的？

image::{oss-images}/guide-5.jpg[]

. 客户端的所有请求都交给前端控制器 `DispatcherServlet` 来处理,它会负责调用系统的其他模块来真正处理用户的请求.
. DispatcherServlet 收到请求后,将根据请求的信息(包括 URL、HTTP 协议方法、请求头、请求参数、Cookie 等)以及 `HandlerMapping` 的配置找到处理该请求的 Handler(任何一个对象都可以作为请求的 Handler).
. 在这个地方 Spring 会通过 `HandlerAdapter` 对该处理器进行封装.
. `HandlerAdapter` 是一个适配器,它用统一的接口对各种 Handler 中的方法进行调用.
. Handler 完成对用户请求的处理后,会返回一个 `ModelAndView` 对象给 `DispatcherServlet`,`ModelAndView` 顾名思义,包含了数据模型以及相应的视图的信息.
. `ModelAndView` 的视图是逻辑视图,`DispatcherServlet` 还要借助 `ViewResolver` 完成从逻辑视图到真实视图对象的解析工作.
. 当得到真正的视图对象后,DispatcherServlet 会利用视图对象对模型数据进行渲染.
. 客户端得到响应,可能是一个普通的 HTML 页面,也可以是 XML 或 JSON 字符串,还可以是一张图片或者一个PDF文件.

[[java-framework-spring-23]]
== Spring IoC 容器配置 Bean 的方式？

* 基于 XML 文件进行配置.
* 基于注解进行配置.
* 基于 Java 程序进行配置(Spring 3+)

[source,java]
----
package com.jackfrued.bean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Person {
    private String name;
    private int age;
    @Autowired
    private Car car;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public void setCar(Car car) {
        this.car = car;
    }
    @Override
    public String toString() {
        return "Person [name=" + name + ", age=" + age + ", car=" + car + "]";
    }
}


@Component
public class Car {
    private String brand;
    private int maxSpeed;
    public Car(String brand, int maxSpeed) {
        this.brand = brand;
        this.maxSpeed = maxSpeed;
    }
    @Override
    public String toString() {
        return "Car [brand=" + brand + ", maxSpeed=" + maxSpeed + "]";
    }
}


@Configuration
public class AppConfig {
    @Bean
    public Car car() {
        return new Car("Benz", 320);
    }
    @Bean
    public Person person() {
        return new Person("骆昊", 34);
    }
}

class Test {
    public static void main(String[] args) {
        // TWR (Java 7+)
        try(ConfigurableApplicationContext factory = new AnnotationConfigApplicationContext(AppConfig.class)) {
            Person person = factory.getBean(Person.class);
            System.out.println(person);
        }
    }
}
----

[[java-framework-spring-24]]
== 阐述 Spring 框架中 Bean 的生命周期？

. Spring IoC 容器找到关于 Bean 的定义并实例化该 Bean.
. Spring IoC 容器对 Bean 进行依赖注入.
. 如果 Bean 实现了 `BeanNameAware` 接口,则将该 Bean 的 id 传给 `setBeanName` 方法.
. 如果 Bean 实现了 `BeanFactoryAware` 接口,则将 BeanFactory 对象传给 `setBeanFactory` 方法.
. 如果 Bean 实现了 `BeanPostProcessor` 接口,则调用其 `postProcessBeforeInitialization` 方法.
. 调用初始化方法，进行初始化， 初始化方法是通过 `init-method` 来指定的.
. 如果 Bean 实现了 `InitializingBean` 接口,则调用其 `afterPropertySet` 方法.
. 如果有和 Bean 关联的 `BeanPostProcessors` 对象,则这些对象的 `postProcessAfterInitialization` 方法被调用.
. 当销毁 Bean 实例时,如果 Bean 实现了 `DisposableBean` 接口,则调用其 `destroy` 方法.

有关 bean 对象的补充

. 在构建 IOC 容器时就已经创建了配置文件中的所声明的 bean 对象
. Bean 对象默认情况下是单例的,多次调用 `getBean()` 获取 bean 对象时是同一个 bean 对象
. 若将 `scope=”prototy”` 则在每次调用 `getbean()` 方法获取 bean 对象时 每次都是一个新的对象.
. 通过 spring 的 Ioc 容器创建实例对象,其中依赖注入是 IOC 的一种典型实现方式,Spring 框架支持构造方法注入和 set 方法注入,不支持接口注入,因为会存在耦合性

[[java-framework-spring-25]]
== Spring 中如何使用注解来配置 Bean？有哪些相关的注解？

首先需要在 Spring 配置文件中增加如下配置:

[source,xml]
----
<context:component-scan base-package="org.example"/>
----

然后可以用 `@Component`、`@Controller`、`@Service`、`@Repository` 注解来标注需要由 Spring IoC 容器进行对象托管的类.这几个注解没有本质区别,只不过 `@Controller` 通常用于控制器,`@Service` 通常用于业务逻辑类,`@Repository` 通常用于仓储类(例如我们的DAO实现类),普通的类用 `@Component` 来标注.

[[java-framework-spring-26]]
== Spring 中 Bean 的作用域有哪些？

在 Spring 的早期版本中,仅有两个作用域: singleton 和 prototype,前者表示 Bean 以单例的方式存在;后者表示每次从容器中调用 Bean 时,都会返回一个新的实例,prototype 通常翻译为原型.
补充:设计模式中的创建型模式中也有一个原型模式,原型模式也是一个常用的模式,例如做一个室内设计软件,所有的素材都在工具箱中,而每次从工具箱中取出的都是素材对象的一个原型,可以通过对象克隆来实现原型模式.

Spring 2.x 中针对 `WebApplicationContext` 新增了 3 个作用域,分别是:request(每次 HTTP 请求都会创建一个新的 Bean)、session(同一个 HttpSession 共享同一个Bean,不同的 HttpSession 使用不同的 Bean)和 globalSession(同一个全局 Session 共享一个 Bean).

说明:单例模式和原型模式都是重要的设计模式.一般情况下,无状态或状态不可变的类适合使用单例模式.在传统开发中,由于 DAO 持有 `Connection` 这个非线程安全对象因而没有使用单例模式;但在 Spring 环境下,所有 DAO 类对可以采用单例模式,因为 Spring 利用 AOP 和 Java API 中的 ThreadLocal 对非线程安全的对象进行了特殊处理.
ThreadLocal 为解决多线程程序的并发问题提供了一种新的思路.`ThreadLocal`,顾名思义是线程的一个本地化对象,当工作于多线程中的对象使用 `ThreadLocal` 维护变量时,`ThreadLocal` 为每个使用该变量的线程分配一个独立的变量副本,所以每一个线程都可以独立的改变自己的副本,而不影响其他线程所对应的副本.从线程的角度看,这个变量就像是线程的本地变量.

ThreadLocal 类非常简单好用,只有四个方法,能用上的也就是下面三个方法:

* void set(T value):设置当前线程的线程局部变量的值.
* T get():获得当前线程所对应的线程局部变量的值.
* void remove():删除当前线程中线程局部变量的值.

`ThreadLocal` 是如何做到为每一个线程维护一份独立的变量副本的呢？在 `ThreadLocal` 类中有一个 Map,键为线程对象,值是其线程对应的变量的副本,自己要模拟实现一个 `ThreadLocal` 类其实并不困难,代码如下所示:

[source,java]
----
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
public class MyThreadLocal<T> {
    private Map<Thread, T> map = Collections.synchronizedMap(new HashMap<Thread, T>());
    public void set(T newValue) {
        map.put(Thread.currentThread(), newValue);
    }
    public T get() {
        return map.get(Thread.currentThread());
    }
    public void remove() {
        map.remove(Thread.currentThread());
    }
}
----

[[java-framework-spring-27]]
== Spring 中自动装配的方式有哪些？

* no:不进行自动装配,手动设置 Bean 的依赖关系.
* byName:根据 Bean 的名字进行自动装配.
* byType:根据 Bean 的类型进行自动装配.
* constructor:类似于 byType,不过是应用于构造器的参数,如果正好有一个 Bean 与构造器的参数类型相同则可以自动装配,否则会导致错误.
* autodetect:如果有默认的构造器,则通过 constructor 的方式进行自动装配,否则使用 byType 的方式进行自动装配.

说明:自动装配没有自定义装配方式那么精确,而且不能自动装配简单属性(基本类型、字符串等),在使用时应注意.

[[java-framework-spring-28]]
== Spring 中的自动装配有哪些限制？

* 如果使用了构造器注入或者 setter 注入,那么将覆盖自动装配的依赖关系.
* 基本数据类型的值、字符串字面量、类字面量无法使用自动装配来注入.
* 优先考虑使用显式的装配来进行更精确的依赖注入而不是使用自动装配.


[[java-framework-spring-31]]
== 解释一下什么叫 AOP(面向切面编程)？

AOP(Aspect-Oriented Programming)指一种程序设计范型,该范型以一种称为切面(aspect)的语言构造为基础,切面是一种新的模块化机制,用来描述分散在对象、类或方法中的横切关注点(crosscutting concern).

[[java-framework-spring-32]]
== 你是如何理解"横切关注"这个概念的？

"横切关注"是会影响到整个应用程序的关注功能,它跟正常的业务逻辑是正交的,没有必然的联系,但是几乎所有的业务逻辑都会涉及到这些关注功能.通常,事务、日志、安全性等关注就是应用中的横切关注功能.

[[java-framework-spring-33]]
== 你如何理解 AOP 中的连接点(Joinpoint)、切点(Pointcut)、增强(Advice)、引介(Introduction)、织入(Weaving)、切面(Aspect)这些概念？

. 连接点(Joinpoint):程序执行的某个特定位置(如:某个方法调用前、调用后,方法抛出异常后).一个类或一段程序代码拥有一些具有边界性质的特定点,这些代码中的特定点就是连接点.Spring 仅支持方法的连接点.
. 切点(Pointcut):如果连接点相当于数据中的记录,那么切点相当于查询条件,一个切点可以匹配多个连接点.Spring AOP 的规则解析引擎负责解析切点所设定的查询条件,找到对应的连接点.
. 增强(Advice):增强是织入到目标类连接点上的一段程序代码.Spring 提供的增强接口都是带方位名的,如:BeforeAdvice、AfterReturningAdvice、ThrowsAdvice 等.很多资料上将增强译为“通知”,这明显是个词不达意的翻译,让很多程序员困惑了许久.
+
说明: Advice 在国内的很多书面资料中都被翻译成"通知",但是很显然这个翻译无法表达其本质,有少量的读物上将这个词翻译为"增强",这个翻译是对 Advice 较为准确的诠释,我们通过 AOP 将横切关注功能加到原有的业务逻辑上,这就是对原有业务逻辑的一种增强,这种增强可以是前置增强、后置增强、返回后增强、抛异常时增强和包围型增强.
. 引介(Introduction):引介是一种特殊的增强,它为类添加一些属性和方法.这样,即使一个业务类原本没有实现某个接口,通过引介功能,可以动态的未该业务类添加接口的实现逻辑,让业务类成为这个接口的实现类.
. 织入(Weaving):织入是将增强添加到目标类具体连接点上的过程,AOP 有三种织入方式:

* 编译期织入:需要特殊的 Java 编译期(例如 AspectJ 的ajc);
* 装载期织入:要求使用特殊的类加载器,在装载类的时候对类进行增强;
* 运行时织入:在运行时为目标类生成代理实现增强.

Spring 采用了动态代理的方式实现了运行时织入,而 AspectJ 采用了编译期织入和装载期织入的方式.

切面(Aspect):切面是由切点和增强(引介)组成的,它包括了对横切关注功能的定义,也包括了对连接点的定义.

补充:代理模式是 GoF 提出的 23 种设计模式中最为经典的模式之一,代理模式是对象的结构模式,它给某一个对象提供一个代理对象,并由代理对象控制对原对象的引用.简单的说,代理对象可以完成比原对象更多的职责,当需要为原对象添加横切关注功能时,
就可以使用原对象的代理对象.我们在打开 Office 系列的 Word 文档时,如果文档中有插图,当文档刚加载时,文档中的插图都只是一个虚框占位符,等用户真正翻到某页要查看该图片时,才会真正加载这张图,这其实就是对代理模式的使用,代替真正图片的虚框就是一个虚拟代理;Hibernate的load方法也是返回一个虚拟代理对象,等用户真正需要访问对象的属性时,才向数据库发出SQL语句获得真实对象.

下面用一个找枪手代考的例子演示代理模式的使用:

[source,java]
----
/*
* 参考人员接口
* @author
*
*/
public interface Candidate {
    /**
* 答题
*/
    public void answerTheQuestions();
}
/**
* 懒学生
* @author 骆昊
*
*/
public class LazyStudent implements Candidate {
    private String name; // 姓名
    public LazyStudent(String name) {
        this.name = name;
    }
    @Override
    public void answerTheQuestions() {
        // 懒学生只能写出自己的名字不会答题
        System.out.println("姓名: " + name);
    }
}
/**
* 枪手
* @author 骆昊
*
*/
public class Gunman implements Candidate {
    private Candidate target; // 被代理对象
    public Gunman(Candidate target) {
        this.target = target;
    }
    @Override
    public void answerTheQuestions() {
        // 枪手要写上代考的学生的姓名
        target.answerTheQuestions();
        // 枪手要帮助懒学生答题并交卷
        System.out.println("奋笔疾书正确答案");
        System.out.println("交卷");
    }
}
public static void main(String[] args) {
    Candidate c = new Gunman(new LazyStudent("王小二"));
    c.answerTheQuestions();
}
}

----



说明:从 JDK 1.3 开始,Java 提供了动态代理技术,允许开发者在运行时创建接口的代理实例,主要包括 `Proxy` 类和 `InvocationHandler` 接口.下面的例子使用动态代理为 `ArrayList` 编写一个代理,在添加和删除元素时,
在控制台打印添加或删除的元素以及 `ArrayList` 的大小:

[source,java]
----
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.List;
public class ListProxy<T> implements InvocationHandler {
    private List<T> target;
    public ListProxy(List<T> target) {
        this.target = target;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable {
        Object retVal = null;
        System.out.println("[" + method.getName() + ": " + args[0] + "]");
        retVal = method.invoke(target, args);
        System.out.println("[size=" + target.size() + "]");
        return retVal;
    }
}
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.List;
public class ProxyTest2 {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        Class<?> clazz = list.getClass();
        ListProxy<String> myProxy = new ListProxy<String>(list);
        List<String> newList = (List<String>)
            Proxy.newProxyInstance(clazz.getClassLoader(),
                                   clazz.getInterfaces(), myProxy);
        newList.add("apple");
        newList.add("banana");
        newList.add("orange");
        newList.remove("banana");
    }
}
----


[NOTE]
====
使用 Java 的动态代理有一个局限性就是代理的类必须要实现接口,虽然面向接口编程是每个优秀的 Java 程序都知道的规则,但现实往往不尽如人意,对于没有实现接口的类如何为其生成代理呢？继承！继承是最经典的扩展已有代码能力的手段,
虽然继承常常被初学者滥用,但继承也常常被进阶的程序员忽视.CGLib 采用非常底层的字节码生成技术,通过为一个类创建子类来生成代理,它弥补了 Java 动态代理的不足,因此 Spring 中动态代理和 CGLib 都是创建代理的重要手段,
对于实现了接口的类就用动态代理为其生成代理类,而没有实现接口的类就用 CGLib 通过继承的方式为其创建代理.
====



[[java-framework-spring-41]]
== Spring 支持的事务管理类型有哪些？你在项目中使用哪种方式？

Spring 支持编程式事务管理和声明式事务管理.许多 Spring 框架的用户选择声明式事务管理,因为这种方式和应用程序的关联较少,因此更加符合轻量级容器的概念.声明
式事务管理要优于编程式事务管理,尽管在灵活性方面它弱于编程式事务管理,因为编程式事务允许你通过代码控制业务.

事务分为全局事务和局部事务.全局事务由应用服务器管理,需要底层服务器 JTA 支持(如 WebLogic、WildFly 等).局部事务和底层采用的持久化方案有关,例如
使用 JDBC 进行持久化时,需要使用 Connetion 对象来操作事务;而采用 Hibernate 进行持久化时,需要使用 Session 对象来操作事务.


[[java-framework-spring-41-tbl]]
.事务管理器
|===
| 事务管理器实现类                    | 目标对象

| DataSourceTransactionManager        | 注入DataSource

| HibernateTransactionManager         | 注入SessionFactory

| JdoTransactionManager               | 管理JDO事务

| JtaTransactionManager               | 使用JTA管理事务

| PersistenceBrokerTransactionManager | 管理Apache的OJB事务
|===

Spring 提供了如下所示的事务管理器.

这些事务的父接口都是 `PlatformTransactionManager`.Spring 的事务管理机制是一种典型的策略模式,`PlatformTransactionManager` 代表事务管理接口,该接口
定义了三个方法,该接口并不知道底层如何管理事务,但是它的实现类必须提供 `getTransaction()` 方法(开启事务)、`commit()` 方法(提交事务)、`rollback()` 方法(回滚事务)的多态实现,
这样就可以用不同的实现类代表不同的事务管理策略.使用 JTA 全局事务策略时,需要底层应用服务器支持,而不同的应用服务器所提供的 JTA 全局事务可能存在细节上的差
异,因此实际配置全局事务管理器是可能需要使用 `JtaTransactionManager` 的子类,如: `WebLogicJtaTransactionManager`(Oracle 的 WebLogic 服
务器提供)、`UowJtaTransactionManager`(IBM 的 WebSphere 服务器提供)等.

编程式事务管理如下所示.

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
       xmlns:p="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
    <context:component-scan base-package="com.jackfrued"/>
    <bean id="propertyConfig"
          class="org.springframework.beans.factory.config.
                 PropertyPlaceholderConfigurer">
        <property name="location">
            <value>jdbc.properties</value>
        </property>
    </bean>
    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
        <property name="driverClassName">
            <value>{db.driver}</value>
        </property>
        <property name="url">
            <value>{db.url}</value>
        </property>
        <property name="username">
            <value>{db.username}</value>
        </property>
        <property name="password">
            <value>{db.password}</value>
        </property>
    </bean>
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource">
            <ref bean="dataSource" />
        </property>
    </bean>
    <!-- JDBC事务管理器-->
    <bean id="transactionManager"
          class="org.springframework.jdbc.datasource.
                 DataSourceTransactionManager" scope="singleton">
        <property name="dataSource">
            <ref bean="dataSource" />
        </property>
    </bean>
    <!-- 声明事务模板-->
    <bean id="transactionTemplate"
          class="org.springframework.transaction.support.
                 TransactionTemplate">
        <property name="transactionManager">
            <ref bean="transactionManager" />
        </property>
    </bean>
</beans>
----

[source,java]
----
package com.jackfrued.dao.impl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import com.jackfrued.dao.EmpDao;
import com.jackfrued.entity.Emp;
@Repository
public class EmpDaoImpl implements EmpDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    @Override
    public boolean save(Emp emp) {
        String sql = "insert into emp values (?,?,?)";
        return jdbcTemplate.update(sql, emp.getId(), emp.getName(), emp.getBirthday()) == 1;
    }
}
package com.jackfrued.biz.impl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;
import com.jackfrued.biz.EmpService;
import com.jackfrued.dao.EmpDao;
import com.jackfrued.entity.Emp;
@Service
public class EmpServiceImpl implements EmpService {
    @Autowired
    private TransactionTemplate txTemplate;
    @Autowired
    private EmpDao empDao;
    @Override
    public void addEmp(final Emp emp) {
        txTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus txStatus) {
                empDao.save(emp);
            }
        });
    }
}
----


声明式事务如下图所示,以 Spring 整合 Hibernate 3 为例,包括完整的 DAO 和业务逻辑代码.

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context-3.2.xsd
                           http://www.springframework.org/schema/aop
                           http://www.springframework.org/schema/aop/spring-aop-3.2.xsd
                           http://www.springframework.org/schema/tx
                           http://www.springframework.org/schema/tx/spring-tx-3.2.xsd">
    <!-- 配置由Spring IoC容器托管的对象对应的被注解的类所在的包-->
    <context:component-scan base-package="com.jackfrued" />
    <!-- 配置通过自动生成代理实现AOP功能-->
    <aop:aspectj-autoproxy />
    <!-- 配置数据库连接池(DBCP) -->
    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
          destroy-method="close">
        <!-- 配置驱动程序类-->
        <property name="driverClassName" value="com.mysql.jdbc.Driver" />
        <!-- 配置连接数据库的URL -->
        <property name="url" value="jdbc:mysql://localhost:3306/myweb" />
        <!-- 配置访问数据库的用户名-->
        <property name="username" value="root" />
        <!-- 配置访问数据库的口令-->
        <property name="password" value="123456" />
        <!-- 配置最大连接数-->
        <property name="maxActive" value="150" />
        <!-- 配置最小空闲连接数-->
        <property name="minIdle" value="5" />
        <!-- 配置最大空闲连接数-->
        <property name="maxIdle" value="20" />
        <!-- 配置初始连接数-->
        <property name="initialSize" value="10" />
        <!-- 配置连接被泄露时是否生成日志-->
        <property name="logAbandoned" value="true" />
        <!-- 配置是否删除超时连接-->
        <property name="removeAbandoned" value="true" />
        <!-- 配置删除超时连接的超时门限值(以秒为单位) -->
        <property name="removeAbandonedTimeout" value="120" />
        <!-- 配置超时等待时间(以毫秒为单位) -->
        <property name="maxWait" value="5000" />
        <!-- 配置空闲连接回收器线程运行的时间间隔(以毫秒为单位) -->
        <property name="timeBetweenEvictionRunsMillis" value="300000" />
        <!-- 配置连接空闲多长时间后(以毫秒为单位)被断开连接-->
        <property name="minEvictableIdleTimeMillis" value="60000" />
    </bean>
    <!-- 配置Spring提供的支持注解ORM映射的Hibernate会话工厂-->
    <bean id="sessionFactory"
          class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean">
        <!-- 通过setter注入数据源属性-->
        <property name="dataSource" ref="dataSource" />
        <!-- 配置实体类所在的包-->
        <property name="packagesToScan" value="com.jackfrued.entity" />
        <!-- 配置Hibernate的相关属性-->
        <property name="hibernateProperties">
            <!-- 在项目调试完成后要删除show_sql和format_sql属性否则对性能有显著影响-->
            <value>
                hibernate.dialect=org.hibernate.dialect.MySQL5Dialect
            </value>
        </property>
    </bean>
    <!-- 配置Spring提供的Hibernate事务管理器-->
    <bean id="transactionManager"
          class="org.springframework.orm.hibernate3.HibernateTransactionManager">
        <!-- 通过setter注入Hibernate会话工厂-->
        <property name="sessionFactory" ref="sessionFactory" />
    </bean>
    <!-- 配置基于注解配置声明式事务-->
    <tx:annotation-driven />
</beans>
----

[source,java]
----
package com.jackfrued.dao;
import java.io.Serializable;
import java.util.List;
import com.jackfrued.comm.QueryBean;
import com.jackfrued.comm.QueryResult;
/**
 * 数据访问对象接口(以对象为单位封装CRUD操作)
 * @author 骆昊
 *
 * @param <E> 实体类型
 * @param <K> 实体标识字段的类型
 */
public interface BaseDao <E, K extends Serializable> {
	/**
	 * 新增
	 * @param entity 业务实体对象
	 * @return 增加成功返回实体对象的标识
	 */
	public K save(E entity);
	/**
	 * 删除
	 * @param entity 业务实体对象
	 */
	public void delete(E entity);
	/**
	 * 根据ID删除
	 * @param id 业务实体对象的标识
	 * @return 删除成功返回true否则返回false
	 */
	public boolean deleteById(K id);
	/**
	 * 修改
	 * @param entity 业务实体对象
	 * @return 修改成功返回true否则返回false
	 */
	public void update(E entity);
	/**
	 * 根据ID查找业务实体对象
	 * @param id 业务实体对象的标识
	 * @return 业务实体对象对象或null
	 */
	public E findById(K id);
	/**
	 * 根据ID查找业务实体对象
	 * @param id 业务实体对象的标识
	 * @param lazy 是否使用延迟加载
	 * @return 业务实体对象对象
	 */
	public E findById(K id, boolean lazy);
	/**
	 * 查找所有业务实体对象
	 * @return 装所有业务实体对象的列表容器
	 */
	public List<E> findAll();
	/**
	 * 分页查找业务实体对象
	 * @param page 页码
	 * @param size 页面大小
	 * @return 查询结果对象
	 */
	public QueryResult<E> findByPage(int page, int size);
	/**
	 * 分页查找业务实体对象
	 * @param queryBean 查询条件对象
	 * @param page 页码
	 * @param size 页面大小
	 * @return 查询结果对象
	 */
	public QueryResult<E> findByPage(QueryBean queryBean, int page, int size);
}
----

[source,java]
----
package com.jackfrued.dao;
import java.io.Serializable;
import java.util.List;
import com.jackfrued.comm.QueryBean;
import com.jackfrued.comm.QueryResult;

// BaseDao的缺省适配器
public abstract class BaseDaoAdapter<E, K extends Serializable> implements
    BaseDao<E, K> {
    @Override
    public K save(E entity) {
        return null;
    }
    @Override
    public void delete(E entity) {
    }
    @Override
    public boolean deleteById(K id) {
        E entity = findById(id);
        if(entity != null) {
            delete(entity);
            return true;
        }
        return false;
    }
    @Override
    public void update(E entity) {
    }
    @Override
    public E findById(K id) {
        return null;
    }
    @Override
    public E findById(K id, boolean lazy) {
        return null;
    }
    @Override
    public List<E> findAll() {
        return null;
    }
    @Override
    public QueryResult<E> findByPage(int page, int size) {
        return null;
    }
    @Override
    public QueryResult<E> findByPage(QueryBean queryBean, int page, int size) {
        return null;
    }
}
----

[source,java]
----
package com.jackfrued.dao;
import java.io.Serializable;
import java.lang.reflect.ParameterizedType;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.springframework.beans.factory.annotation.Autowired;
import com.jackfrued.comm.HQLQueryBean;
import com.jackfrued.comm.QueryBean;
import com.jackfrued.comm.QueryResult;
public abstract class BaseDaoHibernateImpl<E, K extends Serializable> extends BaseDaoAdapter<E, K> {
	@Autowired
	protected SessionFactory sessionFactory;

	private Class<?> entityClass; // 业务实体的类对象

	private String entityName; // 业务实体的名字

	public BaseDaoHibernateImpl() {
		ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass();
		entityClass = (Class<?>) pt.getActualTypeArguments()[0];
		entityName = entityClass.getSimpleName();
	}

	@Override
	public K save(E entity) {
		return (K) sessionFactory.getCurrentSession().save(entity);
	}

	@Override
	public void delete(E entity) {
		sessionFactory.getCurrentSession().delete(entity);
	}

	@Override
	public void update(E entity) {
		sessionFactory.getCurrentSession().update(entity);
	}

	@Override
	public E findById(K id) {
		return findById(id, false);
	}

	@Override
	public E findById(K id, boolean lazy) {
		Session session = sessionFactory.getCurrentSession();
		return (E) (lazy ? session.load(entityClass, id) : session.get(entityClass, id));
	}

	@Override
	public List<E> findAll() {
		return sessionFactory.getCurrentSession().createCriteria(entityClass).list();
	}

	@Override
	public QueryResult<E> findByPage(int page, int size) {
		return new QueryResult<E>(
				findByHQLAndPage("from " + entityName, page, size),
				getCountByHQL("select count() from " + entityName)
		);
	}

	@Override
	public QueryResult<E> findByPage(QueryBean queryBean, int page, int size) {
		if (queryBean instanceof HQLQueryBean) {
			HQLQueryBean hqlQueryBean = (HQLQueryBean) queryBean;
			return new QueryResult<E>(
					findByHQLAndPage(hqlQueryBean.getQueryString(), page, size, hqlQueryBean.getParameters()),
					getCountByHQL(hqlQueryBean.getCountString(), hqlQueryBean.getParameters())
			);
		}
		return null;
	}

	/**
	 * 根据HQL和可变参数列表进行查询
	 *
	 * @param hql 基于HQL的查询语句
	 * @param params 可变参数列表
	 * @return 持有查询结果的列表容器或空列表容器
	 */
	protected List<E> findByHQL(String hql, Object... params) {
		return this.findByHQL(hql, getParamList(params));
	}

	/**
	 * 根据HQL和参数列表进行查询
	 *
	 * @param hql 基于HQL的查询语句
	 * @param params 查询参数列表
	 * @return 持有查询结果的列表容器或空列表容器
	 */
	protected List<E> findByHQL(String hql, List<Object> params) {
		List<E> list = createQuery(hql, params).list();
		return list != null && list.size() > 0 ? list : Collections.EMPTY_LIST;
	}

	/**
	 * 根据HQL和参数列表进行分页查询
	 *
	 * @param hql 基于HQL的查询语句
	 * @param params 可变参数列表
	 * @return 持有查询结果的列表容器或空列表容器
	 */
	protected List<E> findByHQLAndPage(String hql, int page, int size, Object... params) {
		return this.findByHQLAndPage(hql, page, size, getParamList(params));
	}

	/**
	 * 根据HQL和参数列表进行分页查询
	 *
	 * @param hql 基于HQL的查询语句
	 * @param params 查询参数列表
	 * @return 持有查询结果的列表容器或空列表容器
	 */
	protected List<E> findByHQLAndPage(String hql, int page, int size, List<Object> params) {
		List<E> list = createQuery(hql, params)
				.setFirstResult((page - 1) * size)
				.setMaxResults(size)
				.list();
		return list != null && list.size() > 0 ? list : Collections.EMPTY_LIST;
	}

	/**
	 * 查询满足条件的记录数
	 *
	 * @param hql 基于HQL的查询语句
	 * @param params 可变参数列表
	 * @return 满足查询条件的总记录数
	 */
	protected long getCountByHQL(String hql, Object... params) {
		return this.getCountByHQL(hql, getParamList(params));
	}

	/**
	 * 查询满足条件的记录数
	 *
	 * @param hql 基于HQL的查询语句
	 * @param params 参数列表容器
	 * @return 满足查询条件的总记录数
	 */
	protected long getCountByHQL(String hql, List<Object> params) {
		return (Long) createQuery(hql, params).uniqueResult();
	}

	// 创建Hibernate查询对象(Query)
	private Query createQuery(String hql, List<Object> params) {
		Query query = sessionFactory.getCurrentSession().createQuery(hql);
		for (int i = 0; i < params.size(); i++) {
			query.setParameter(i, params.get(i));
		}
		return query;
	}

	// 将可变参数列表组装成列表容器
	private List<Object> getParamList(Object... params) {
		List<Object> paramList = new ArrayList<>();
		if (params != null) {
			for (int i = 0; i < params.length; i++) {
				paramList.add(params[i]);
			}
		}
		return paramList.size() == 0 ? Collections.EMPTY_LIST : paramList;
	}
}
----

[source,java]
----
package com.jackfrued.comm;
import java.util.List;
public interface QueryBean {
	/**
	 * 添加排序字段
	 * @param fieldName 用于排序的字段
	 * @param asc 升序还是降序
	 * @return 查询条件对象自身(方便级联编程)
	 */
	public QueryBean addOrder(String fieldName, boolean asc);

	/**
	 * 添加排序字段
	 * @param available 是否添加此排序字段
	 * @param fieldName 用于排序的字段
	 * @param asc 升序还是降序
	 * @return 查询条件对象自身(方便级联编程)
	 */
	public QueryBean addOrder(boolean available, String fieldName, boolean asc);

	/**
	 * 添加查询条件
	 * @param condition 条件
	 * @param params 替换掉条件中参数占位符的参数
	 * @return 查询条件对象自身(方便级联编程)
	 */
	public QueryBean addCondition(String condition, Object... params);

	/**
	 * 添加查询条件
	 * @param available 是否需要添加此条件
	 * @param condition 条件
	 * @param params 替换掉条件中参数占位符的参数
	 * @return 查询条件对象自身(方便级联编程)
	 */
	public QueryBean addCondition(boolean available, String condition, Object... params);

	/**
	 * 获得查询语句
	 * @return 查询语句
	 */
	public String getQueryString();

	/**
	 * 获取查询记录数的查询语句
	 * @return 查询记录数的查询语句
	 */
	public String getCountString();

	/**
	 * 获得查询参数
	 * @return 查询参数的列表容器
	 */
	public List<Object> getParameters();
}
----

[source,java]
----
package com.jackfrued.comm;
import java.util.List;

// 查询结果
public class QueryResult<T> {
	private List<T> result; // 持有查询结果的列表容器
	private long totalRecords; // 查询到的总记录数

	/**
	 * 构造器
	 */
	public QueryResult() {
	}

	/**
	 * 构造器
	 *  @param result 持有查询结果的列表容器
	 *  @param totalRecords 查询到的总记录数
	 */
	public QueryResult(List<T> result, long totalRecords) {
		this.result = result;
		this.totalRecords = totalRecords;
	}
	public List<T> getResult() {
		return result;
	}
	public void setResult(List<T> result) {
		this.result = result;
	}
	public long getTotalRecords() {
		return totalRecords;
	}
	public void setTotalRecords(long totalRecords) {
		this.totalRecords = totalRecords;
	}
}

----

[source,java]
----
package com.jackfrued.dao;
import com.jackfrued.comm.QueryResult;
import com.jackfrued.entity.Dept;
/**
 * 部门数据访问对象接口
 * @author 骆昊
 */
public interface DeptDao extends BaseDao<Dept, Integer> {

    /**
     * 分页查询顶级部门
     * @param page 页码
     * @param size 页码大小
     * @return 查询结果对象
     */
    public QueryResult<Dept> findTopDeptByPage(int page, int size);
}

package com.jackfrued.dao.impl;
import java.util.List;
import org.springframework.stereotype.Repository;
import com.jackfrued.comm.QueryResult;
import com.jackfrued.dao.BaseDaoHibernateImpl;
import com.jackfrued.dao.DeptDao;
import com.jackfrued.entity.Dept;
@Repository
public class DeptDaoImpl extends BaseDaoHibernateImpl<Dept, Integer> implements DeptDao {
    private static final String HQL_FIND_TOP_DEPT = " from Dept as d where d.superiorDept is null ";
    @Override
    public QueryResult<Dept> findTopDeptByPage(int page, int size) {
        List<Dept> list = findByHQLAndPage(HQL_FIND_TOP_DEPT, page, size);
        long totalRecords = getCountByHQL(" select count() " + HQL_FIND_TOP_DEPT);
        return new QueryResult<>(list, totalRecords);
    }
}

----

[source,java]
----
package com.jackfrued.comm;
import java.util.List;
//分页器
public class PageBean<T> {
	private static final int DEFAUL_INIT_PAGE = 1;
	private static final int DEFAULT_PAGE_SIZE = 10;
	private static final int DEFAULT_PAGE_COUNT = 5;
	private List<T> data; // 分页数据
	private PageRange pageRange; // 页码范围
	private int totalPage; // 总页数
	private int size; // 页面大小
	private int currentPage; // 当前页码
	private int pageCount; // 页码数量
	/**
     * 构造器
     * @param currentPage 当前页码
     * @param size 页码大小
     * @param pageCount 页码数量
	 */
	public PageBean(int currentPage, int size, int pageCount) {
		this.currentPage = currentPage > 0 ? currentPage : 1;
		this.size = size > 0 ? size : DEFAULT_PAGE_SIZE;
		this.pageCount = pageCount > 0 ? size : DEFAULT_PAGE_COUNT;
	}

	/**
     * 构造器
     * @param currentPage 当前页码
     * @param size 页码大小
	 */
	public PageBean(int currentPage, int size) {
		this(currentPage, size, DEFAULT_PAGE_COUNT);
	}

	/**
     * 构造器
     * @param currentPage 当前页码
	 */
	public PageBean(int currentPage) {
		this(currentPage, DEFAULT_PAGE_SIZE, DEFAULT_PAGE_COUNT);
	}

	/**
     * 构造器
	 */
	public PageBean() {
		this(DEFAUL_INIT_PAGE, DEFAULT_PAGE_SIZE, DEFAULT_PAGE_COUNT);
	}
	public List<T> getData() {
		return data;
	}
	public int getStartPage() {
		return pageRange != null ? pageRange.getStartPage() : 1;
	}
	public int getEndPage() {
		return pageRange != null ? pageRange.getEndPage() : 1;
	}
	public long getTotalPage() {
		return totalPage;
	}
	public int getSize() {
		return size;
	}
	public int getCurrentPage() {
		return currentPage;
	}

	/**
     * 将查询结果转换为分页数据
     * @param queryResult 查询结果对象
	 */
	public void transferQueryResult(QueryResult<T> queryResult) {
		long totalRecords = queryResult.getTotalRecords();
		data = queryResult.getResult();
		totalPage = (int) ((totalRecords + size - 1) / size);
		totalPage = totalPage >= 0 ? totalPage : Integer.MAX_VALUE;
		this.pageRange = new PageRange(pageCount, currentPage, totalPage);
	}
}
----

[source,java]
----
package com.jackfrued.comm;
public class PageRange {
	private int startPage; // 起始页码
	private int endPage; // 终止页码

	/**
	 * 构造器
	 * @param pageCount 总共显示几个页码
	 * @param currentPage 当前页码
	 * @param totalPage 总页数
	 */
	public PageRange(int pageCount, int currentPage, int totalPage) {
		startPage = currentPage - (pageCount - 1) / 2;
		endPage = currentPage + pageCount / 2;
		if(startPage < 1) {
			startPage = 1;
			endPage = totalPage > pageCount ? pageCount : totalPage;
		}
		if (endPage > totalPage) {
			endPage = totalPage;
			startPage = (endPage - pageCount > 0) ? endPage - pageCount + 1 : 1;
		}
	}

	/**
	 * 获得起始页页码
	 * @return 起始页页码
	 */
	public int getStartPage() {
		return startPage;
	}

	/**
	 * 获得终止页页码
	 * @return 终止页页码
	 */
	public int getEndPage() {
		return endPage;
	}
}

----

[source,java]
----
package com.jackfrued.biz;
import com.jackfrued.comm.PageBean;
import com.jackfrued.entity.Dept;

// 部门业务逻辑接口
public interface DeptService {

	/**
	 *  创建新的部门
	 *  @param department 部门对象
	 *  @return 创建成功返回true否则返回false
	 */
	public boolean createNewDepartment(Dept department);

	/**
	 * 删除指定部门
	 * @param id 要删除的部门的编号
	 * @return 删除成功返回true否则返回false
	 */
	public boolean deleteDepartment(Integer id);

	/**
	 * 分页获取顶级部门
	 * @param page 页码
	 * @param size 页码大小
	 * @return 部门对象的分页器对象
	 */
	public PageBean<Dept> getTopDeptByPage(int page, int size);
}

----

[source,java]
----
package com.jackfrued.biz.impl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.jackfrued.biz.DeptService;
import com.jackfrued.comm.PageBean;
import com.jackfrued.comm.QueryResult;
import com.jackfrued.dao.DeptDao;
import com.jackfrued.entity.Dept;
@Service
@Transactional // 声明式事务的注解
public class DeptServiceImpl implements DeptService {
    @Autowired
    private DeptDao deptDao;
    @Override
    public boolean createNewDepartment(Dept department) {
        return deptDao.save(department) != null;
    }
    @Override
    public boolean deleteDepartment(Integer id) {
        return deptDao.deleteById(id);
    }
    @Override
    public PageBean<Dept> getTopDeptByPage(int page, int size) {
        QueryResult<Dept> queryResult = deptDao.findTopDeptByPage(page, size);
        PageBean<Dept> pageBean = new PageBean<>(page, size);
        pageBean.transferQueryResult(queryResult);
        return pageBean;
    }
}
----

[[java-framework-spring-42]]
== 如何配置配置事务增强？

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
                           http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/tx
                           http://www.springframework.org/schema/tx/spring-tx.xsd
                           http://www.springframework.org/schema/aop
                           http://www.springframework.org/schema/aop/spring-aop.xsd">
    <!-- this is the service object that we want to make transactional -->
    <bean id="fooService" class="x.y.service.DefaultFooService"/>
    <!-- the transactional advice -->
    <tx:advice id="txAdvice" transaction-manager="txManager">
        <!-- the transactional semantics... -->
        <tx:attributes>
            <!-- all methods starting with 'get' are read-only -->
            <tx:method name="get*" read-only="true"/>
            <!-- other methods use the default transaction settings (see below) -->
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>
    <!-- ensure that the above transactional advice runs for any execution
of an operation defined by the FooService interface -->
    <aop:config>
        <aop:pointcut id="fooServiceOperation"
                      expression="execution(* x.y.service.FooService.*(..))"/>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/>
    </aop:config>
    <!-- don't forget the DataSource -->
    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
          destroy-method="close">
        <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
        <property name="url" value="jdbc:oracle:thin:@localhost:1521:orcl"/>
        <property name="username" value="scott"/>
        <property name="password" value="tiger"/>
    </bean>
    <!-- similarly, don't forget the PlatformTransactionManager -->
    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!-- other <bean/> definitions here -->
</beans>
----

[[java-framework-spring-51]]
== 简单说一下 SpringMVC 几个常用注解

[[java-framework-spring-4-tbl]]
.常用注解
|===
| 注解                     | 说明

| @Controller              | 定义控制器

| @RequestMapping          | 注解将 URL 映射到整个类或特定的处理方法上,还可以指定匹配方法

| @PathVariable            | 注解方法参数并将其绑定到 URI 模板变量的值上

| @RequestParam            | 将请求的参数绑定到方法中的参数上(required=false)

| @ResponseBody            | 将返回类型直接输入到 HTTP response body 中.输出 JSON 格式的数据时用

| @ModelAttribute          | 作用添加一个或多个模型属性(model attributes)

| @requestBody;@HttpEntity |
|===

[[java-framework-spring-52]]
== SpringMVC 与 Struts2 区别

. Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter
. Spring MVC 会稍微比 Struts2 快些. Spring MVC 是基于方法设计, 而 Sturts2 是基于类, 每次发一次请求都会实例一个 Action.
. Spring MVC 使用更加简洁, 开发效率Spring MVC比struts2高: 支持JSR303, 处理 ajax 的请求更方便
. Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些.

[[java-framework-spring-61]]
== Spring 循环依赖问题

常见问法:

* 请解释一下 spring 中的三级缓存
* 三级缓存分别是什么?三个 Map 有什么异同?
* 什么是循环依赖?请你谈谈?看过 spring 源码吗?
* 如何检测是否存在循环依赖?实际开发中见过循环依赖的异常吗?
* 多例的情况下,循环依赖问题为什么无法解决?

三级缓存


|===
|  | 对象名 | 类型 | 含义

|缓存 |singletonObjects | ConcurrentHashMap | 存放已经经历了完整生命周期的 Bean 对象

|缓存 | earlySingletonObjects | HashMap | 存放早期暴露出来的 Bean 对象，Bean 的生命周期未结束（属性还未填充完)

|缓存 | singletonFactories | HashMap | 存放可以生成 Bean 的工厂
|===


. Spring 创建 bean 主要分为两个步骤，创建原始 bean 对象，接着去填充对象属性和初始化。
. 每次创建 bean 之前，我们都会从缓存中查下有没有该 bean，因为是单例，只能有一个。
. 当创建 A 的原始对象后，并把它放到三级缓存中，接下来就该填充对象属性了，这时候发现依赖了B，接着就
又去创建 B，同样的流程，创建完 B 填充属性时又发现它依赖了 A 又是同样的流程，不同的是：这时候可以在三级
缓存中查到刚放进去的原始对象 A。
所以不需要继续创建，用它注入 B，完成 B 的创建既然 B 创建好了，所以 A 就可以完成填充属性的步骤了，接
着执行剩下的逻辑，闭环完成。

Spring 解决循环依赖依靠的是 Bean 的"中间态"这个概念，而这个中间态指的是已经实例化但还没初始化的状态—>
半成品。实例化的过程又是通过构造器创建的，如果 A 还没创建好出来怎么可能提前曝光，所以构造器的循环依赖
无法解决。

=== 为什么构造器注入属性无法解决循环依赖问题?

由于 spring 中的 bean 的创建过程为先实例化 再初始化(在进行对象实例化的过程中不必赋值)将实例化好的对
象暴露出去,供其他对象调用,然而使用构造器注入,必须要使用构造器完成对象的初始化的操作,就会陷入死循环的
状态。

=== 一级缓存能不能解决循环依赖问题?

不能

在三个级别的缓存中存储的对象是有区别的 一级缓存为完全实例化且初始化的对象 二级缓存实例化但未初
始化对象 如果只有一级缓存,如果是并发操作下,就有可能取到实例化但未初始化的对象,就会出现问题

=== 二级缓存能不能解决循环依赖问题?

理论上二级缓存可以解决循环依赖问题,但是需要注意,为什么需要在三级缓存中存储匿名内部类
(ObjectFactory),原因在于需要创建代理对象 eg:现有 A 类,需要生成代理对象 A 是否需要进行实例化(需要) 在三
级缓存中存放的是生成具体对象的一个匿名内部类,该类可能是代理类也可能是普通的对象,而使用三级缓存可以保
证无论是否需要是代理对象,都可以保证使用的是同一个对象,而不会出现,一会儿使用普通 bean 一会儿使用代理类



