[[mysql]]
= Mysql

[[guide-sql-4]]
== 数据库索引的实现


数据库系统还维护着满足特定查找算法的数据结构,这些数据结构以某种方式引用(指向)数据,这样就可以在这些数据结构上实现高级查找算法.这种数据结构,就是索引.

B树:

一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树.它或者是空树,或者是满足下列性质的树:

. 根结点至少有两个子女;
. 每个非根节点所包含的关键字个数 j 满足: ┌m/2┐ - 1 <= j <= m - 1;
. 除根结点以外的所有结点(不包括叶子结点)的度数正好是关键字总数加1,故内部子树个数 k 满足: ┌m/2┐ <= k <= m ;
. 所有的叶子结点都位于同一层.

由于B-Tree的特性,在B-Tree中按key检索数据的算法非常直观: 首先从根节点进行二分查找,如果找到则返回对应节点的data,否则对相应区间的指针指向的节点递归进行查找,直到找到节点或找到null指针,前者查找成功,后者查找失败.

一个度为d的B-Tree,设其索引N个key,则其树高h的上限为 `logd((N+1)/2)`,检索一个key,其查找节点个数的渐进复杂度为 `O(logdN)`.从这点可以看出,B-Tree 是一个非常有效率的索引数据结构.

B+树:

B-Tree 有许多变种,其中最常见的是B+Tree,例如MySQL就普遍使用B+Tree实现其索引结构.

B+树是B树的变形,它把所有的data都放在叶子结点中,只将关键字和子女指针保存于内结点,内结点完全是索引的功能.

与 B-Tree 相比,B+Tree 有以下不同点:

. 每个节点的指针上限为2d而不是2d+1.

. 内节点不存储data,只存储key;叶子节点存储data不存储指针.

一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化,增加了顺序访问指针.

在 B+Tree 的每个叶子节点增加一个指向相邻叶子节点的指针

例如图4中如果要查询key为从18到49的所有数据记录,当找到18后,只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点,极大提到了区间查询效率.

为什么B树(B+树)？

一般来说,索引本身也很大,不可能全部存储在内存中,因此索引往往以索引文件的形式存储的磁盘上.这样的话,索引查找过程中就要产生磁盘I/O消耗,相对于内存存取,I/O存取的消耗要高几个数量级,所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度.换句话说,索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数.

这涉及到磁盘存取原理、局部性原理和磁盘预读.

先从B-Tree分析,根据B-Tree的定义,**可知检索一次最多需要访问h个节点.数据库系统的设计者巧妙利用了磁盘预读原理,将一个节点的大小设为等于一个页,这样每个节点只需要一次I/O就可以完全载入.**为了达到这个目的,在实际实现B-Tree还需要使用如下技巧:

**每次新建节点时,直接申请一个页的空间,这样就保证一个节点物理上也存储在一个页里,加之计算机存储分配都是按页对齐的,就实现了一个node只需一次I/O.**

**B-Tree中一次检索最多需要h-1次I/O(根节点常驻内存),渐进复杂度为O(h)=O(logdN).一般实际应用中,出度d是非常大的数字,通常超过100,因此h非常小(通常不超过3).**

综上所述,用B-Tree作为索引结构效率是非常高的.

而红黑树这种结构,h明显要深的多.由于逻辑上很近的节点(父子)物理上可能很远,无法利用局部性,所以红黑树的I/O渐进复杂度也为O(h),效率明显比B-Tree差很多.

至于B+Tree为什么更适合外存索引,原因和内节点出度d有关.

由于B+Tree内节点去掉了data域,因此可以拥有更大的出度,拥有更好的性能.

== SQL 的 select 语句完整的执行顺序

SQL Select 语句完整的执行顺序：

. from 子句组装来自不同数据源的数据；
. where 子句基于指定的条件对记录行进行筛选；
. group by 子句将数据划分为多个分组；
. 使用聚集函数进行计算；
. 使用 having 子句筛选分组；
. 计算所有的表达式；
. select 的字段；
. 使用 order by 对结果集进行排序。

== MySQL 的事务

<<guide-web-7>>

== 简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别

InnoDB 存储引擎
主要面向 OLTP(Online Transaction Processing，在线事务处理)方面的应用
特点：
行锁设计、支持外键；
MyISAM 存储引擎
主要面向 OLAP(Online Analytical Processing,在线分析处理)方面的应用。
特点：
不支持事务，支持表所和全文索引。操作速度快。

== 悲观锁和乐观锁的怎么实现？

悲观锁：`select...for update` 是 MySQL 提供的实现悲观锁的方式。
例如：`select price from item where id=100 for update`

此时在 items 表中， id 为 100 的那条数据就被我们锁定了，其它的要执行 `select price from items where id=100 for update` 的事务必须等本次事务提交之后才能执行。
这样我们可以保证当前的数据不会被其它事务修改。MySQL 有个问题是 `select...for update` 语句执行中所有扫描过的行都会被锁上，因此在 MySQL 中用悲观锁务必须确定走了索引，而
不是全表扫描，否则将会将整个数据表锁住。

乐观锁：乐观锁相对悲观锁而言，它认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正
式对数据的冲突与否进行检测，如果发现冲突了，则让返回错误信息，让用户决定如何去做。

利用数据版本号（version）机制是乐观锁最常用的一种实现方式。一般通过为数据库表增加一个数字类型的 "version" 字段，当读取数据时，将 `version` 字段的值一同读出，数据每更新一次，对此 `version` 值 `+1`。当我们提交更新的时候，
判断数据库表对应记录的当前版本信息与第一次取出来的 `version` 值进行比对，如果数据库表当前版本号与第一次
取出来的 `version` 值相等，则予以更新，否则认为是过期数据，返回更新失败。

举例：

[source,sql]
----
## 1: 查询出商品信息
select (quantity,version) from items where id=100;
## 2: 根据商品信息生成订单
insert into orders(id,item_id) values(null,100);
## 3: 修改商品的库存
update items set quantity=quantity-1,version=version+1 where id=100 and version=#{version};
----

== 你们公司有哪些数据库设计规范

=== 基础规范
. 表存储引擎必须使用 InnoD，表字符集默认使用 utf8，必要时候使用 utf8mb4
** 解读：
*** 通用，无乱码风险，汉字 3 字节，英文 1 字节
*** utf8mb4 是 utf8 的超集，有存储 4 字节例如表情符号时，使用它
. 禁止使用存储过程，视图，触发器，Event
** 解读：
*** 对数据库性能影响较大，互联网业务，能让站点层和服务层干的事情，不要交到数据库层
*** 调试，排错，迁移都比较困难，扩展性较差
. 禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统，数据库中存储路径
. 禁止在线上环境做数据库压力测试
. 测试，开发，线上数据库环境必须隔离

=== 命名规范

. 库名，表名，列名必须用小写，采用下划线分隔
** 解读
*** abc，Abc，ABC 都是给自己埋坑
. 库名，表名，列名必须见名知义，长度不要超过 32 字符
** 解读
*** tmp，wushan 谁知道这些库是干嘛的
. 库备份必须以 bak 为前缀，以日期为后缀
. 从库必须以 `-s` 为后缀
. 备库必须以 `-ss` 为后缀

=== 表设计规范

. 单实例表个数必须控制在 2000 个以内
. 单表分表个数必须控制在 1024 个以内
. 表必须有主键，推荐使用 UNSIGNED 整数为主键
** 潜在坑：删除无主键的表，如果是 row 模式的主从架构，从库会挂住
. 禁止使用外键，如果要保证完整性，应由应用程式实现
** 解读
*** 外键使得表之间相互耦合，影响 update/delete 等SQL 性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈
. 建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据

=== 列设计规范
. 根据业务区分使用 tinyint/int/bigint，分别会占用 1/4/8 字节
. 根据业务区分使用 char/varchar
** 解读：
*** 字段长度固定，或者长度近似的业务场景，适合使用 char，能够减少碎片，查询性能高
*** 字段长度相差较大，或者更新较少的业务场景，适合使用 varchar，能够减少空间
. 根据业务区分使用 datetime/timestamp
** 解读
*** 前者占用 5 个字节，后者占用 4 个字节，存储年使用 YEAR，存储日期使用 DATE，存储时间使用 datetime
. 必须把字段定义为 NOT NULL 并设默认值
** 解读：
*** NULL 的列使用索引，索引统计，值都更加复杂，MySQL 更难优化
*** NULL 需要更多的存储空间
*** NULL 只能采用 IS NULL 或者 IS NOT NULL，而在=/!=/in/not in 时有大坑
. 使用 INT UNSIGNED 存储 IPv4，不要用 char(15)
. 使用 varchar(20)存储手机号，不要使用整数
** 解读：
*** 牵扯到国家代号，可能出现+/-/()等字符，例如+86
*** 手机号不会用来做数学运算
*** varchar 可以模糊查询，例如 like ‘138%’
. 使用 TINYINT 来代替 ENUM
** 解读：
*** ENUM 增加新值要进行 DDL 操作

=== 索引规范
. 唯一索引使用 uniq_[字段名]来命名
. 非唯一索引使用 idx_[字段名]来命名
. 单张表索引数量建议控制在 5 个以内
** 解读：
*** 互联网高并发业务，太多索引会影响写性能
*** 生成执行计划时，如果索引太多，会降低性能，并可能导致 MySQL 选择不到最优索引
*** 异常复杂的查询需求，可以选择 ES 等更为适合的方式存储
. 组合索引字段数不建议超过 5 个
** 解读
*** 如果 5 个字段还不能极大缩小 row 范围，八成是设计有问题
. 不建议在频繁更新的字段上建立索引
. 非必要不要进行 JOIN 查询，如果要进行 JOIN 查询，被 JOIN 的字段必须类型相同，并建立索引
** 解读
*** 踩过因为 JOIN 字段类型不一致，而导致全表扫描的坑么？
. 理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)

=== SQL 规范
. 禁止使用 select *，只获取必要字段
** 解读
*** `select *` 会增加 cpu/io/内存/带宽的消耗
*** 指定字段能有效利用索引覆盖
*** 指定字段查询，在表结构变更时，能保证对应用程序无影响
. insert 必须指定字段，禁止使用 insert into T values()
** 解读
*** 指定字段插入，在表结构变更时，能保证对应用程序无影响
. 隐式类型转换会使索引失效，导致全表扫描
. 禁止在 where 条件列使用函数或者表达式
** 解读：导致不能命中索引，全表扫描
. 禁止负向查询以及%开头的模糊查询
** 解读：导致不能命中索引，全表扫描
. 禁止大表 JOIN 和子查询
. 同一个字段上的 OR 必须改写问 IN，IN 的值必须少于 50 个
. 应用程序必须捕获 SQL 异常
** 解读：方便定位线上问题

说明：本规范适用于并发量大，数据量大的典型互联网业务，可直接参考。

== 有没有设计过数据表?你是如何设计的?


|===
| 范式 | 说明

| 第一范式
| 每一列属性(字段)不可分割的,字段必须保证原子性两列的属性值相近或者一样的,尽量合并到一列或者分表,确保数据不冗余

| 第二范式
| 每一行的数据只能与其中一行有关 即 主键 一行数据只能做一件事情或者表达一个意思，只要数据出现重复,就要进行表的拆分

| 第三范式
| 数据不能存在传递关系,每个属性都跟主键有直接关联而不是间接关联
|===

== 聚簇索引与非聚簇索引有什么区别

都是 `B+` 树的数据结构

聚簇索引:将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存
放顺序与索引顺序是一致的，即:只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。

非聚簇索引叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置再取磁盘查找数据，
这个就有点类似一本书的目录，比如我们要找第三章第一节，那我们先在这个目录里面找，找到对应的页码后再去
对应的页码看文章。

优势:

. 查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询(非覆盖索引的情况下)效率要高
. 聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的
. 聚簇索引适合用在排序的场合，非聚簇索引不适合

劣势:

. 维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(pagesplit)的时候。建议在大量插入新行后，选在
负载较低的时间段，通过 OPTIMIZETABLE 优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以
弱化碎片
. 表因为使用 uuId(随机 ID)作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用 int 的 auto_increment 作为主键
. 如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值，过长的主键值，会导
致非叶子节点占用占用更多的物理空间

== 索引的底层实现是什么？什么情况下会索引失效？

InnoDB 存储引擎是用 B+Tree 实现其索引结构

失效条件：
. 如果条件中有 or，即使其中有条件带索引也不会使用(这也是为什么尽量少用 or 的原因) 要想使用 or，又想让索引生效，只能将 or 条件中的每个列都加上索引
. 对于多列索引，不是使用的第一部分，则不会使用索引
. like 查询以 `%` 开头
. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
. 如果 mysql 估计使用全表扫描要比使用索引快,则不使用索引
. 组合索引要遵循 最左匹配原则

== 以 MySQL 为例 Linux 下如何排查问题?

. 架构层面 是否使用主从
. 表结构层面 是否满足常规的表设计规范(大量冗余字段会导致查询会变得很复杂)
. sql 语句层面
+
前提:由于慢查询日志记录默认是关闭的,所以开启数据库 mysql 的慢查询记录的功能 从慢查询日志中去获取哪些 sql 语句时慢查询 默认 10S ,从中获取到 sql 语句进行分析
+
.. explain 分析一条 sql

[source,text]
----
mysql> explain select * from saga_user;
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | saga_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |   100.00 | NULL  |
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
----

id: 执行顺序 如果单表的话,无参考价值 如果是关联查询,会据此判断主表 从表
select_type: simple
table: 表
partitions
type: ALL 未创建索引 、const 常量 、ref 其他索引 、eq_ref 主键索引
possible_keys:
key: 实际是到到索引到字段
key_len: 索引字段数据结构所使用长度 与是否有默认值 null 以及对应字段到数据类型有关，有一个理论值 有一个实际使用值也即 key_len 的值
ref
rows: 检索的行数 与查询返回的行数无关
filtered
Extra: 常见的值：usingfilesort 使用磁盘排序算法进行排序，事关排序 分组 的字段是否使用索引的核心参考值
还可能这样去提问：sql 语句中哪些位置适合建索引/索引建立在哪个位置

== 如何处理慢查询

在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会
定期将业务中的慢查询反馈给我们。

慢查询的优化首先要搞明白慢的原因是什么?是查询条件没有命中索引?是加载了不需要的数据列?还是数据量太大?

所以优化也是针对这三个方向来的:

* 首先分析语句，看看是否加载了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。
* 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。
* 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。

== 数据库分表操作

可以说使用 Mycat 或者 ShardingSphere 等中间件来做，具体怎么做就要结合具体的场景进行分析了。

可以参考：https://database.51cto.com/art/201809/583857.html[https://database.51cto.com/art/201809/583857.html]

== MySQL 优化

. 尽量选择较小的列
. 将 where 中用的比较频繁的字段建立索引
. select 子句中避免使用‘*’
. 避免在索引列上使用计算、not in 和<>等操作
. 当只需要一行数据的时候使用 limit 1
. 保证单表数据不超过 200W，适时分割表。针对查询较慢的语句，可以使用 explain 来分析该语句具体的执行情况。
. 避免改变索引列的类型。
. 选择最有效的表名顺序，from 字句中写在最后的表是基础表，将被最先处理，在 from 子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。
. 避免在索引列上面进行计算。
. 尽量缩小子查询的结果

== SQL 语句优化案例

=== where 子句中可以对字段进行 null 值判断吗？

可以，比如 select id from t where num is null 这样的 sql 也是可以的。但是最好不要给数据库留 NULL，尽可能的
使用 NOT NULL 填充数据库。不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了，
不管是否插入值（NULL 也包含在内），都是占用 100 个字符的空间的，如果是 varchar 这样的变长字段，null 不
占用空间。可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询： `select id from t where num=0`。

=== 如何优化?下面的语句？

`select * from admin left join log on admin.admin_id = log.admin_id where log.admin_id>10`
优化为：`select * from (select * from admin where admin_id>10) T1 lef join log on T1.admin_id = log.admin_id`。

使用 JOIN 时候，应该用小的结果驱动大的结果（left join 左边表结果尽量小如果有条件应该放到左边先处理， right
join 同理反向），同时尽量把牵涉到多表联合的查询拆分多个 query （多个连表查询效率低，容易到之后锁表和阻塞）。

=== limit 的基数比较大时使用 between

例如：`select * from admin order by admin_id limit 100000,10`
优化为：`select * from admin where admin_id between 100000 and 100010 order by admin_id`。

=== 尽量避免在列上做运算，这样导致索引失效

例如：`select * from admin where year(admin_time)>2014`
优化为： `select * from admin where admin_time> '2014-01-01′`

[[guide-sql-5]]
== 案例1

[[guide-sql-5-student-tbl]]
.Student 学生表
|===
| 表字段                     | 说明

| SID              | 主键

| Sname         | 名字

| Sage           | 年龄

| Ssex           | 性别

| Sbirth           | 生日
|===

[[guide-sql-5-course-tbl]]
.Course 课程表
|===
| 表字段                     | 说明

| CID              | 主键

| Cname         | 名字

| TID           | 教师ID
|===

[[guide-sql-5-sc-tbl]]
.SC 成绩表
|===
| 表字段                     | 说明

| SID              | 主键

| CID         | 课程ID

| score           | 分数
|===

[[guide-sql-5-teacher-tbl]]
.Teacher 教师表
|===
| 表字段                     | 说明

| TID              | 主键

| Tname         | 名字
|===

1、查询201课程比202课程成绩高的所有学生的学号

[source,sql]
----
select a.SID from (select Sid,score from SC where CID=201) a,(select Sid,score from SC where CID=202) b where a.score>b.score a.score>b.score and a.Sid=b.Sid;
----

2、查询平均成绩大于60分的同学的学号和平均成绩;

[source,sql]
----
select SID,avg(score) from sc group by SID having avg(score) >60;
----

3、查询所有同学的学号、姓名、选课数、总成绩;

[source,sql]
----
select Student.SID,Student.Sname,count(SC.CID),sum(score) from Student left Outer join SC on Student.SID=SC.SID
    group by Student.SID,Sname
----

4、查询姓“李”的老师的个数;

[source,sql]
----
select count(distinct(Tname))
from Teacher
where Tname like '李%';
----

5、查询没学过“叶平”老师课的同学的学号、姓名;

[source,sql]
----
select Student.SID,Student.Sname
from Student
where SID not in (select distinct(SC.SID) from SC,Course,Teacher
                  where SC.CID=Course.CID and Teacher.TID=Course.TID and Teacher.Tname='叶平');
select student.sid,student.sname
from student
where sid not in (
    select sid
    from sc
    where cid in (
        select cid
        from course
        where tid = (select tid
                     from teacher
                     where tname = '叶平')
    )
)
----

6、查询学过“201”并且也学过编号“202”课程的同学的学号、姓名;

[source,sql]
----
select Student.SID,Student.Sname
from Student,SC
where Student.SID=SC.SID and SC.CID='001'and exists(
    Select * from SC as SC_2 where SC_2.SID=SC.SID and SC_2.CID='002');
----

7、查询学过“叶平”老师所教的所有课的同学的学号、姓名;

[source,sql]
----
select SID,Sname
from Student
where SID in (select SID from SC ,Course ,Teacher
              where SC.CID=Course.CID and Teacher.TID=Course.TID and Teacher.Tname='叶平'
              group by SID having count(SC.CID)=(select count(CID) from Course,Teacher
                                                 where Teacher.TID=Course.TID and Tname='叶平'));
----


8、查询课程编号“202”的成绩比课程编号“201”课程低的所有同学的学号、姓名;

[source,sql]
----
Select SID,Sname from (select Student.SID,Student.Sname,score ,(select score from SC SC_2 where SC_2.SID=Student.SID and SC_2.CID='002') score2
                       from Student,SC where Student.SID=SC.SID and CID='001') S_2 where score2 <score;
----

9、查询所有课程成绩小于60分的同学的学号、姓名;
(取反操作处理)

[source,sql]
----
select SID,Sname
from Student
where SID not in (select Student.SID from Student,SC where S.SID=SC.SID and score>60);
----

10、查询没有学全所有课的同学的学号、姓名;

(count(CID)得到课程的数目)

[source,sql]
----
select Student.SID,Student.Sname
from Student,SC
where Student.SID=SC.SID group by Student.SID,Student.Sname having count(CID) <(select count(CID) from Course);
----


11、查询至少有一门课与学号为“1001”的同学所学相同的同学的学号和姓名;

[source,sql]
----
select SID,Sname from Student,SC where Student.SID=SC.SID and CID in (select CID from SC where SID='1001');
----

12、查询至少学过学号为“1001”同学所有一门课的其他同学学号和姓名;

[source,sql]
----
select distinct SC.SID,Sname
from Student,SC
where Student.SID=SC.SID and CID in (select CID from SC where SID='001')
and Student.SID <> 1001;
----


13、把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩;

[source,sql]
----
update SC
set score=(select avg(SC_2.score)
           from SC SC_2
           where SC_2.CID=SC.CID )
where cid = (
    select cid
    from Course,Teacher
    where Course.CID=SC.CID and Course.TID=Teacher.TID and Teacher.Tname='叶平'
)
----


14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名;

[source,sql]
----
select SID
from SC
where CID in (select CID from SC where SID='1002')
group by SID having count(*)=(select count(*) from SC where SID='1002');
----

15、删除学习“叶平”老师课的SC表记录;

[source,sql]
----
Delete from sc
where cid = (
    select cid
    from course ,Teacher
    where Course.CID=SC.CID and Course.TID= Teacher.TID and Tname='叶平'
)

----

16、向SC表中插入一些记录,这些记录要求符合以下条件: 没有上过编号“003”课程的同学学号、002号课的平均成绩;

[source,sql]
----
Insert into SC
as select SID,'002',(Select avg(score)
                     from SC where CID='002')
from Student
where SID not in (Select SID from SC where CID='002');
----

17、按学生平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩,按如下形式显示: 学生ID,数据库,企业管理,英语,有效课程数,有效平均分
(默认数据库是004,企业管理是001,英语是006)

[source,sql]
----
SELECT SID as 学生ID
,(SELECT score FROM SC WHERE SC.SID=t.SID AND CID='004') AS 数据库
,(SELECT score FROM SC WHERE SC.SID=t.SID AND CID='001') AS 企业管理
,(SELECT score FROM SC WHERE SC.SID=t.SID AND CID='006') AS 英语
,COUNT(*) AS 有效课程数, AVG(t.score) AS 平均成绩
FROM SC AS t
GROUP BY SID
ORDER BY avg(t.score)
----

18、查询各科成绩最高和最低的分,以及对应的学号: 以如下形式显示: 课程ID,最高分,学号,最低分,学号

[source,sql]
----
SELECT L.CID courseID,L.score 最高分,L.sid 学号,R.score 最低分,R.sid 学号
FROM SC L ,SC R
WHERE L.CID = R.CID and
L.score = (SELECT MAX(IL.score)
           FROM SC IL,Student IM
           WHERE L.CID = IL.CID and IM.SID=IL.SID
           GROUP BY IL.CID)
AND
R.Score = (SELECT MIN(IR.score)
           FROM SC IR
           WHERE R.CID = IR.CID
           GROUP BY IR.CID)
----

19、查询课程号,课程名称,平均成绩和及格率,并按各科平均成绩从低到高和及格率的百分数从高到低顺序

[source,sql]
----
SELECT t.CID AS 课程号,max(course.Cname)AS 课程名,isnull(AVG(score),0) AS 平均成绩
,100 * SUM(CASE WHEN isnull(score,0)>=60 THEN 1 ELSE 0 END)/COUNT(*) AS 及格百分数
FROM SC T,Course
where t.CID=course.CID
GROUP BY t.CID
ORDER BY 100 * SUM(CASE WHEN isnull(score,0)>=60 THEN 1 ELSE 0 END)/COUNT(*) DESC
----

20、查询如下课程平均成绩和及格率的百分数(用"1行"显示): 企业管理(001),马克思(002),OO&UML (003),数据库(004)

[source,sql]
----
SELECT SUM(CASE WHEN CID ='001' THEN score ELSE 0 END)/SUM(CASE CID WHEN '001' THEN 1 ELSE 0 END) AS 企业管理平均分
,100 * SUM(CASE WHEN CID = '001' AND score >= 60 THEN 1 ELSE 0 END)/SUM(CASE WHEN CID = '001' THEN 1 ELSE 0 END) AS 企业管理及格百分数
,SUM(CASE WHEN CID = '002' THEN score ELSE 0 END)/SUM(CASE CID WHEN '002' THEN 1 ELSE 0 END) AS 马克思平均分
,100 * SUM(CASE WHEN CID = '002' AND score >= 60 THEN 1 ELSE 0 END)/SUM(CASE WHEN CID = '002' THEN 1 ELSE 0 END) AS 马克思及格百分数
,SUM(CASE WHEN CID = '003' THEN score ELSE 0 END)/SUM(CASE CID WHEN '003' THEN 1 ELSE 0 END) AS UML平均分
,100 * SUM(CASE WHEN CID = '003' AND score >= 60 THEN 1 ELSE 0 END)/SUM(CASE WHEN CID = '003' THEN 1 ELSE 0 END) AS UML及格百分数
,SUM(CASE WHEN CID = '004' THEN score ELSE 0 END)/SUM(CASE CID WHEN '004' THEN 1 ELSE 0 END) AS 数据库平均分
,100 * SUM(CASE WHEN CID = '004' AND score >= 60 THEN 1 ELSE 0 END)/SUM(CASE WHEN CID = '004' THEN 1 ELSE 0 END) AS 数据库及格百分数
FROM SC
----

21、查询不同老师所教不同课程平均分从高到低显示

[source,sql]
----
SELECT max(Z.TID) AS 教师ID,MAX(Z.Tname) AS 教师姓名,C.CID AS 课程ＩＤ,MAX(C.Cname) AS 课程名称,AVG(Score) AS 平均成绩
FROM SC AS T,Course AS C ,Teacher AS Z
where T.CID=C.CID and C.TID=Z.TID
GROUP BY C.CID
ORDER BY AVG(Score) DESC
----

22、查询如下课程成绩第 3 名到第 6 名的学生成绩单: 企业管理(001),马克思(002),UML (003),数据库(004)
[学生ID],[学生姓名],企业管理,马克思,UML,数据库,平均成绩

[source,sql]
----
SELECT DISTINCT top 3
SC.SID As 学生学号,
Student.Sname AS 学生姓名 ,
T1.score AS 企业管理,
T2.score AS 马克思,
T3.score AS UML,
T4.score AS 数据库,
ISNULL(T1.score,0) + ISNULL(T2.score,0) + ISNULL(T3.score,0) + ISNULL(T4.score,0) as 总分
FROM Student,SC LEFT JOIN SC AS T1
ON SC.SID = T1.SID AND T1.CID = '001'
LEFT JOIN SC AS T2
ON SC.SID = T2.SID AND T2.CID = '002'
LEFT JOIN SC AS T3
ON SC.SID = T3.SID AND T3.CID = '003'
LEFT JOIN SC AS T4
ON SC.SID = T4.SID AND T4.CID = '004'
WHERE student.SID=SC.SID and
ISNULL(T1.score,0) + ISNULL(T2.score,0) + ISNULL(T3.score,0) + ISNULL(T4.score,0)
NOT IN
(SELECT
 DISTINCT
 TOP 15 WITH TIES
 ISNULL(T1.score,0) + ISNULL(T2.score,0) + ISNULL(T3.score,0) + ISNULL(T4.score,0)
 FROM sc
 LEFT JOIN sc AS T1
 ON sc.SID = T1.SID AND T1.CID = 'k1'
 LEFT JOIN sc AS T2
 ON sc.SID = T2.SID AND T2.CID = 'k2'
 LEFT JOIN sc AS T3
 ON sc.SID = T3.SID AND T3.CID = 'k3'
 LEFT JOIN sc AS T4
 ON sc.SID = T4.SID AND T4.CID = 'k4'
 ORDER BY ISNULL(T1.score,0) + ISNULL(T2.score,0) + ISNULL(T3.score,0) + ISNULL(T4.score,0) DESC);
----

23、统计各科成绩,各分数段人数:课程ID,课程名称,[100-85],[85-70],[70-60],[ <60]

[source,sql]
----
SELECT SC.CID as 课程ID, Cname as 课程名称
,SUM(CASE WHEN score BETWEEN 85 AND 100 THEN 1 ELSE 0 END) AS [100 - 85]
,SUM(CASE WHEN score BETWEEN 70 AND 85 THEN 1 ELSE 0 END) AS [85 - 70]
,SUM(CASE WHEN score BETWEEN 60 AND 70 THEN 1 ELSE 0 END) AS [70 - 60]
,SUM(CASE WHEN score < 60 THEN 1 ELSE 0 END) AS [60 -]
FROM SC,Course
where SC.CID=Course.CID
GROUP BY SC.CID,Cname;
----

24、查询学生平均成绩及其名次

[source,sql]
----
SELECT 1+(SELECT COUNT( distinct 平均成绩)
          FROM (SELECT SID,AVG(score) AS 平均成绩
                FROM SC
                GROUP BY SID
               ) AS T1
          WHERE 平均成绩> T2.平均成绩) as 名次,
SID as 学生学号,平均成绩
FROM (SELECT SID,AVG(score) 平均成绩
      FROM SC
      GROUP BY SID
     ) AS T2
ORDER BY 平均成绩desc;
----

25、查询各科成绩前三名的记录:(不考虑成绩并列情况)

[source,sql]
----
SELECT t1.SID as 学生ID,t1.CID as 课程ID,Score as 分数
FROM SC t1
WHERE score IN (SELECT TOP 3 score
                FROM SC
                WHERE t1.CID= CID
                ORDER BY score DESC
               )
ORDER BY t1.CID;
----

26、查询每门课程被选修的学生数

[source,sql]
----
select Cid,count(SID) from sc group by CID;
----

27、查询出只选修了一门课程的全部学生的学号和姓名

[source,sql]
----
select SC.SID,Student.Sname,count(CID) AS 选课数
from SC ,Student
where SC.SID=Student.SID group by SC.SID ,Student.Sname having count(CID)=1;
----

28、查询男生、女生人数

[source,sql]
----
Select count(Ssex) as 男生人数 from Student group by Ssex having Ssex='男';
Select count(Ssex) as 女生人数 from Student group by Ssex having Ssex='女';
----

29、查询姓“张”的学生名单

[source,sql]
----
SELECT Sname FROM Student WHERE Sname like '张%';
----

30、查询同名学生名单,并统计同名人数

[source,sql]
----
select Sname,count(*) from Student group by Sname having count(*)>1;
----

31、1981年出生的学生名单(注:Student表中Sage列的类型是datetime)

[source,sql]
----
select Sname, CONVERT(char (11),DATEPART(year,Sage)) as age
from student
where CONVERT(char(11),DATEPART(year,Sage))='1981';
----

32、查询每门课程的平均成绩,结果按平均成绩升序排列,平均成绩相同时,按课程号降序排列

[source,sql]
----
Select CID,Avg(score) from SC group by CID order by Avg(score),CID DESC ;
----

33、查询平均成绩大于85的所有学生的学号、姓名和平均成绩

[source,sql]
----
select Sname,SC.SID ,avg(score)
from Student,SC
where Student.SID=SC.SID group by SC.SID,Sname having avg(score)>85;
----

34、查询课程名称为“数据库”,且分数低于60的学生姓名和分数

[source,sql]
----
Select Sname,isnull(score,0)
from Student,SC,Course
where SC.SID=Student.SID and SC.CID=Course.CID and Course.Cname='数据库'and score <60;
----

35、查询所有学生的选课情况; (学号,姓名,课程编号,课程名字)

[source,sql]
----
SELECT SC.SID,SC.CID,Sname,Cname
FROM SC,Student,Course
where SC.SID=Student.SID and SC.CID=Course.CID ;
----

36、查询任何一门课程成绩在70分以上的学号、姓名、课程编号和分数;

[source,sql]
----
SELECT distinct student.SID,student.Sname,SC.CID,SC.score
FROM student,Sc
WHERE SC.score>=70 AND SC.SID=student.SID;
----

37、查询学生学号,以及其不及格的课程,并按课程号从大到小排列

[source,sql]
----
select sid,Cid from sc where score <60 order by CID ;
----

38、查询课程编号为003且课程成绩在80分以上的学生的学号和姓名;

[source,sql]
----
select SC.SID,Student.Sname from SC,Student where SC.SID=Student.SID and Score>80 and CID='003';
----

39、求选了课程的学生人数

[source,sql]
----
select count(*) from sc;
----

40、查询选修“叶平”老师所授课程的学生中,成绩最高的学生姓名及其成绩

[source,sql]
----
select Student.Sname,score
from Student,SC,CourseC,Teacher
where Student.SID=SC.SID and SC.CID=C.CID and C.TID=Teacher.TID and Teacher.Tname='叶平' and SC.score=(select max(score)from SC where CID=C.CID );
----

41、查询各个课程及相应的选修人数

[source,sql]
----
select count(*) from sc group by CID;
----

42、查询不同课程成绩相同的学生的学号、课程号、学生成绩

[source,sql]
----
select distinct A.SID,B.score from SC A ,SC B where A.Score=B.Score and A.CID <>B.CID ;
----


43、查询每门功成绩最好的前两名

[source,sql]
----
SELECT t1.SID as 学生ID,t1.CID as 课程ID,Score as 分数
FROM SC t1
WHERE score IN (SELECT TOP 2 score
                FROM SC
                WHERE t1.CID= CID
                ORDER BY score DESC
               )
ORDER BY t1.CID;
----

44、统计每门课程的学生选修人数(超过10人的课程才统计).要求输出课程号和选修人数,查询结果按人数降序排列,查询结果按人数降序排列,若人数相同,按课程号升序排列

[source,sql]
----
select CID as 课程号,count(*) as 人数
from sc
group by CID
order by count(*) desc,Cid
----

45、检索至少选修两门课程的学生学号

[source,sql]
----
select SID
from sc
group by Sid
having count(*) > = 2
----

46、查询全部学生都选修的课程的课程号和课程名

[source,sql]
----
select CID,Cname
from Course
where CID in (select Cid from sc group by Cid)
----

47、查询没学过“叶平”老师讲授的任一门课程的学生姓名

[source,sql]
----
select Sname from Student where SID not in (select SID from Course,Teacher,SC where Course.TID=Teacher.TID and SC.CID=course.CID and Tname='叶平');
----

48、查询两门以上不及格课程的同学的学号及其平均成绩

[source,sql]
----
select SID,avg(isnull(score,0)) from SC where SID in (select SID from SC where score <60 group by SID having count(*)>2)group by SID;
----

== 案例2

=== SQL1

用一条 SQL 语句查询出每门课都大于 80 分的学生姓名

|===
| name |kecheng | fenshu

| 张三 | 语文 | 81
| 张三 | 数学 | 75
| 李四 | 语文 | 76
| 李四 | 数学 | 90
| 王五 | 语文 | 81
| 王五 | 数学 | 100
| 王五 | 英语 | 90
|===

答：

* select distinct name from table where name not in (select distinct name from table where fenshu<=80)
* select name from table group by name having min(fenshu)>80

=== SQL2

删除除了自动编号不同，其他都相同的学生冗余信息

学生表 如下:

|===
| 自动编号 | 学号 | 姓名 | 课程编号 | 课程名称 | 分数

| 1 | 2005001 | 张三 | 0001 | 数学 | 69
| 2 | 2005002 | 李四 | 0001 | 数学 | 89
| 3 | 2005001 | 张三 | 0001 | 数学 | 69
|===

答： delete tablename where 自动编号 not in(select min(自动编号) from tablename group by 学号, 姓名, 课程编号, 课
程名称, 分数)

=== SQL3

一个叫 team 的表，里面只有一个字段 name,一共有4 条纪录，分别是 a,b,c,d,对应四个球队，现在四个球队进行比赛，
用一条 sql 语句显示所有可能的比赛组合.

答：select a.name, b.name from team a, team b where a.name < b.name

=== SQL4

怎么把这样一个表

|===
| year | month | amount

| 1991 | 1 | 1.1
| 1991 | 2 | 1.2
| 1991 | 3 | 1.3
| 1991 | 4 | 1.4
| 1992 | 1 | 2.1
| 1992 | 2 | 2.2
| 1992 | 3 | 2.3
| 1992 | 4 | 2.4
|===

查成这样一个结果

|===
| year | m1 | m2 | m3 | m4

| 1991 | 1.1 | 1.2 | 1.3 | 1.4
| 1992 | 2.1 | 2.2 | 2.3 | 2.4
|===

答：select year,
    (select amount from aaa m where month=1 and m.year=aaa.year) as m1,
    (select amount from aaa m where month=2 and m.year=aaa.year) as m2,
    4. (select amount from aaa m where month=3 and m.year=aaa.year) as m3,
    5. (select amount from aaa m where month=4 and m.year=aaa.year) as m4
    6. from aaa group by year

=== SQL5

说明：复制表(只复制结构,源表名：a 新表名：b)

答：

SQL: select * into b from a where 1<>1 (where1=1，拷贝表结构和数据内容)
ORACLE：create table b As Select * from a where 1=2

[<>（不等于）(SQL Server Compact) 比较两个表达式。 当使用此运算符比较非空表达式时，如果左操作数不等于右操作数，则结果为 TRUE。 否则，
结果为 FALSE。]

=== SQL6

原表：

|===
| courseid | coursename | score

| 1 | java | 70
| 2 | oracle | 90
| 3 | xml | 40
| 4 | jsp | 30
| 5 | servlet | 80
|===

为了便于阅读,查询此表后的结果显式如下(及格分数为 60):

|===
| courseid | coursename | score | mark
| 1 | java | 70 | pass
| 2 | oracle | 90 | pass
| 3 | xml | 40 | fail
| 4 | jsp | 30 | fail
| 5 | servlet | 80 | pass
|===

写出此查询语句

答：

select courseid, coursename ,score ,if(score>=60, "pass","fail") as mark from course

=== 例 7：
表名：购物信息

|===
| 购物人 | 商品名称 | 数量
| A | 甲 | 2
| B | 乙 | 4
| C | 丙 | 1
| A | 丁 | 2
| B | 丙 | 5
|===

给出所有购入商品为两种或两种以上的购物人记录

答：

select * from 购物信息 where 购物人 in (select 购物人 from 购物信息 group by 购物人 having count(*) >= 2);

=== 例 8：

info 表

|===
| date | result
| 2005-05-09 | win
| 2005-05-09 | lose
| 2005-05-09 | lose
| 2005-05-09 | lose
| 2005-05-10 | win
| 2005-05-10 | lose
| 2005-05-10 | lose
|===

如果要生成下列结果, 该如何写 sql 语句?

|===
| date | win | lose
| 2005-05-09 | 2 | 2
| 2005-05-10 | 1 | 2
|===

答 1：
select date, sum(case when result = "win" then 1 else 0 end) as "win", sum(case when result = "lose" then
1 else 0 end) as "lose" from info group by date;

答 2：
select a.date, a.result as win, b.result as lose
    from
    (select date, count(result) as result from info where result = "win" group by date) as a
    join
    (select date, count(result) as result from info where result = "lose" group by date) as b
    on a.date = b.date;


