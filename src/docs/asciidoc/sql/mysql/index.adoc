[[sql-mysql-index]]
= MySQL 索引

== MySQL 如何实现的索引机制?

MySQL中索引分三类:B+ 树索引、Hash 索引、全文索引

== 聚簇索引与非聚簇索引有什么区别

都是 `B+` 树的数据结构

聚簇索引:将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存
放顺序与索引顺序是一致的，即:只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。

非聚簇索引叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置再取磁盘查找数据，
这个就有点类似一本书的目录，比如我们要找第三章第一节，那我们先在这个目录里面找，找到对应的页码后再去
对应的页码看文章。

优势:

. 查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询(非覆盖索引的情况下)效率要高
. 聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的
. 聚簇索引适合用在排序的场合，非聚簇索引不适合

劣势:

. 维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(pagesplit)的时候。建议在大量插入新行后，选在
负载较低的时间段，通过 OPTIMIZETABLE 优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以
弱化碎片
. 表因为使用 uuId(随机 ID)作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用 int 的 auto_increment 作为主键
. 如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值，过长的主键值，会导
致非叶子节点占用占用更多的物理空间

== 聚簇索引与非聚簇索引 b+ 树实现有什么区别?

=== 聚簇索引

特点:

* 索引和数据保存在同一个B+树中
* 页内的记录是按照主键的大小顺序排成一个单向链表 。
* 页和页之间也是根据页中记录的主键的大小顺序排成一个双向链表 。
* 非叶子节点存储的是记录的 主键+页号 。 叶子节点存储的是 完整的用户记录 。

优点:

* 数据访问更快 ，因为索引和数据保存在同一个B+树中 ，因此从聚簇索引中获取数据比非聚簇索引更快。
* 聚簇索引对于主键的排序查找和范围查找速度非常快。 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连 ，数据库可以从更少的数据块中提取数据，节省了大量的 IO 操作 。

缺点:

* 插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影 响性能。因此，对于InnoDB表，我们一般都会定义一个 自增的ID列为主键 。
* 更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义 主键为不可更新。

限制：

* 只有 InnoDB 引擎支持聚簇索引， MyISAM 不支持聚簇索引 。
* 由于数据的物理存储排序方式只能有一种，所以 每个 MySQL 的表只能有一个聚簇索引 。
* 如果没有为表定义主键，InnoDB 会选择 非空的唯一索引列代替 。如果没有这样的列，InnoDB 会隐式的定义一个主键，作为聚簇索引。
* 为了充分利用聚簇索引的聚簇特性，InnoDB 中表的 主键应选择有序的 id ，不建议使用无序的 id，比 如 UUID、MD5、HASH、字符串作为主键，无法保证数据的顺序增长。

=== 非聚簇索引

(二级索引、辅助索引)

聚簇索引 ，只能在搜索条件是 主键值 时才发挥作用，因为 B+ 树中的数据都是按照主键进行排序的，如果 我们想以别的列作为搜索条件，那么需要创建 非聚簇索引 。
例如， 以 c2 列作为搜索条件 ，那么需要使 用 c2 列创建一棵 B+ 树 ，如下所示:

image::{oss-images}/mysql-index05.svg[]

这个 B+ 树与聚簇索引有几处不同:

* 页内的记录是按照从 c2 列的大小顺序排成一个单向链表 。
* 页和页之间也是根据页中记录的 c2 列的大小顺序排成一个双向链表 。
* 非叶子节点存储的是记录的 c2列+页号 。
* 叶子节点存储的并不是完整的用户记录，而只是 c2列+主键 这两个列的值。

**一张表可以有多个非聚簇索引**

== CRUD 时聚簇索引与非聚簇索引的区别是什么?

* 聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复
* 聚簇索引范围，排序查找效率高，因为是有序的
* 非聚簇索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据

== 说一下 B+ 树中聚簇索引的查找(匹配)逻辑


例如:根据 c2 列的值查找 `c2=4` 的记录，查找过程如下:

image::{oss-images}/mysql-index05.svg[]

1. 根据 根页面 44 定位到 页42 (因为 2<=4<9)
2. 由于 c2 列没有唯一约束，所以 c2=4 的记录可能分布在多个数据页中，又因为 2<=4<=4，所以确定实际存储用户记录的页在 页34 和 页35 中
3. 在 页34 和 35 中定位到具体的记录
4. 但是这个 B+ 树的叶子节点只存储了 c2 列和 c1（主键） 列的值，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。
5. like 张%

== 索引的底层实现是什么？什么情况下会索引失效？

InnoDB 存储引擎是用 B+Tree 实现其索引结构

失效条件：

. 如果条件中有 or，即使其中有条件带索引也不会使用(这也是为什么尽量少用 or 的原因) 要想使用 or，又想让索引生效，只能将 or 条件中的每个列都加上索引
. 对于多列索引，不是使用的第一部分，则不会使用索引
. like 查询以 `%` 开头
. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
. 如果 MySQL 估计使用全表扫描要比使用索引快,则不使用索引
. 组合索引要遵循 最左匹配原则

== InnoDB 索引与 MyISAM 索引实现的区别是什么?

|===
| 区别  | InnoDB | MyISAM

| 存储方式
| InnoDB使用聚簇索引（Clustered Index），也称为主键索引，数据行实际存储在主键索引的叶子节点上；InnoDB 的数据文件本身就是索引文件。
InnoDB 的表在磁盘上存储在以下文件中: .ibd(表结构、索引和数据都存在一起)
| 而MyISAM使用非聚簇索引（Non-clustered Index），数据行存储在独立的数据文件中。而 MyISAM 索引文件和数据文件是分离的 ，索引文件 仅保存数据记录的地址。
MyISAM 的表在磁盘上存储在以下文件中: *.sdi(描述表结构) 、 *.MYD(数据) ， *.MYI(索引)

| 查找方式
| 在 InnoDB 存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录
| MyISAM 中却需要进行一次回表操作，意味着 MyISAM 中建立的索引相当于全部都是二级索引

| 事务支持
| InnoDB 支持事务处理，具备ACID（原子性、一致性、隔离性和持久性）特性，可以进行回滚和提交操作。
| MyISAM 不支持事务处理，只支持简单的表级锁定。

| 缓存
| 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响
| 只缓存索引，不缓存真实数据

| 行表锁
| InnoDB 通过行级锁定（Row-level Locking）实现高并发性能，不同的事务可以并发地访问同一张表的不同数据行；
| MyISAM 只支持表级锁定（Table-level Locking），多个并发事务可能会相互阻塞。

| 外键约束
| InnoDB 支持外键约束（Foreign Key Constraint），可以定义关联关系和级联操作；
| MyISAM 不支持外键约束

| 数据一致性
| InnoDB 对于崩溃恢复和故障保护有更好的支持，具备自动崩溃恢复和故障保护机制；
| MyISAM 没有内置的崩溃恢复机制，容易造成数据损坏。

| 关注点
| 并发写、事务、多表关系、更大资源
| 并发查询，节省资源、消耗少、简单业务

| 默认安装
| Y
| Y

| 默认使用
| Y
| N

| 自带系 统表使 用
| N
| Y
|===

[[sql-mysql-4]]
== 说一下 B+ 树索引实现原理

假设有一个表 `index_demo`，表中有 2 个 INT 类型的列，1 个 `CHAR(1)` 类型的列，c1 列为主键:

[source,sql]
----
CREATE TABLE index_demo(c1 INT,c2 INT,c3 CHAR(1),PRIMARY KEY(c1)) ;
----

index_demo 表的简化的行格式示意图如下:

image::{oss-images}/mysql-index01.svg[]

我们只在示意图里展示记录的这几个部分:

* record_type: 表示记录的类型， 0是普通记录、 2是最小记录、 3 是最大记录、1是 B+ 树非叶子 节点记录。
* next_record: 表示下一条记录的相对位置，我们用箭头来表明下一条记录。
* 各个列的值: 这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。
* 其他信息: 除了上述 3 种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

将 其他信息 项暂时去掉并把它竖起来的效果就是这样:

image::{oss-images}/mysql-index02.svg[]

把一些记录放到页里的示意图就是(这里一页就是一个磁盘块，代表一次IO):

image::{oss-images}/mysql-index03.svg[]

MySQL InnoDB 默认的页大小是 16KB，因此数据存储在磁盘中，可能会占用多个数据页。如果各个页中
的记录没有规律，我们就不得不依次遍历所有的数据页。如果我们想要快速的定位到需要查找的记录在那些数据页中 ，我们可以这样做 :

* 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值
* 给所有的页建立目录项

以 页28 为例，它对应目录项 2 ，这个目录项中包含着该页的 页号28 以及该页中用户记录的 最小主键值 5。我们只需要把几个目录项在物理存储器上连续存储(比如:数组)，就可以实现根据主键值快速查
找某条记录的功能了。

1. 先从目录项中根据二分法快速确定出 (因为 12 ≤ 20 < 209 )，对应页 9 。
2. 再到页 9 中根据二分法快速定位到主键值为 20 的用户记录。

至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为索引 。

== 平衡二叉树，红黑树，B 树和 B+ 树的区别是什么?都有哪些应用场景?

=== 平衡二叉树

* 基础数据结构
* 左右平衡
* 高度差大于1会自旋
* 每个节点记录一个数据

平衡二叉树(AVL)

AVL树全称G.M. Adelson-Velsky和E.M. Landis，这是两个人的人名。
平衡二叉树也叫平衡二叉搜索树(Self-balancing binary search tree)又被称为AVL树， 可以保证查询 效率较高。

具有一下特点：

* 它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1
* 并且左右两个子树都是一棵平衡二叉树。

AVL的问题

众所周知，IO操作的效率很低，在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中， 只能逐节点加载(一个节点一次IO)。如果我们利用二叉树作为索引结构，
。那么磁盘的 IO 次数是和索引树的高度是相关的。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。

为了提高查询效率，就需要 减少磁盘IO数 。为了减少磁盘的 IO 次数，就要尽量的降低树的高度 ，需要把原 来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。针对同样的数据，如果我们把二叉树改成 三 叉树:

=== 红黑树

* hashmap存储
* 两次旋转达到平衡
* 分为红黑节点

在这个棵严格的平台树上又进化为“红黑树”{是一个非严格的平衡树 左子树与右子树的高度差不能超过 1}，红黑树的长子树只要不超过短子树的两倍即可!

image::{oss-images}/mysql-index06.svg[]

当再次插入 7 的时候，这棵树就会发生旋转

image::{oss-images}/mysql-index07.svg[]


=== B 树和 B+ 树

B+ 树和 B 树的差异:

* B+ 树中非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大值(或 最小)。
* B+树中非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而B树 中， 非叶子节点既保存索引，也保存数据记录 。
* B+树中所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字 的大小从小到大顺序链接。

== 一个 B+ 树中大概能存放多少条索引记录?

真实环境中一个页存放的记录数量是非常大的(默认 16KB)，假设指针与键值忽略不计(或看做 10 个字节)，数据占 1 kb 的空间:

* 如果 B+ 树只有 1 层，也就是只有 1 个用于存放用户记录的节点，最多能存放 16 条记录。
* 如果 B+ 树有 2 层，最多能存放 1600×16=25600 条记录。
* 如果 B+ 树有 3 层，最多能存放 1600×1600×16=40960000
* 如果存储千万级别的数据，只需要三层就够了

== 什么是自适应哈希索引?

自适应哈希索引是 Innodb 引擎的一个特殊功能，当它注意到某些索引值被使用的非常频繁时，会在内存 中基于 B-Tree 所有之上再创建一个哈希索引，这就让 B-Tree 索引也具有哈希索引的一些优点，比如快速哈希查找。
这是一个完全自动的内部行为，用户无法控制或配置。

== 为什么官方建议使用自增长主键作为索引?

* 自增主键能够维持底层数据顺序写入
* 读取可以由 b+ 树的二分查找定位
* 支持范围查找，范围数据自带顺序

== 使用 int 自增主键后，最大 id 是 10，删除 id 10 和 9，再添加一条记录，最后添加 的 id 是几?删除后重启 MySQL 然后添加一条记录最后 id 是几?

* 如果重启，会从最大的 id 开始递增
* 如果没重启，会延续删除之前最大的 id 开始递增

== 索引的优缺点是什么?

优点：

聚簇(主键)索引:

* 顺序读写
* 范围快速查找
* 范围查找自带顺序

非聚簇索引:

* 条件查询避免全表扫描scan
* 范围，排序，分组查询返回行 id，排序分组后，再回表查询完整数据，有可能利用顺序读写
* 覆盖索引不需要回表操作

索引的代价

索引是个好东西，可不能乱建，它在空间和时间上都会有消耗:

空间上的代价:: 每建立一个索引都要为它建立一棵 B+ 树，每一颗 B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间 ，一棵很大的 B+ 树由许多数据页组成，那就是很大的一片存储空间。
时间上的代价:: 每次对表中的数据进行增删改操作时，都需要去修改各个 B+ 树索引，而更改有可能会对节点的排序造成破坏，所以存储引擎需要额外的时间来进行一些记录移位，页面
分裂，页面回收等操作来维护好节点的顺序。如果我们建了许多索引，每个索引对应的 B+ 树都要进行相关的维护操作，会给性能拖后腿。

== 使用索引一定能提升效率吗?

不一定

* 少量数据全表扫描也很快，可以直接获取到全量数据
* 唯一索引会影响插入速度，但建议使用
* 索引过多会影响更新，插入，删除数据速度

== 如果是大段文本内容，如何创建(优化)索引?

* 第一种方式是分表存储，然后创建索引
* 第二是使用 es 为大文本创建索引

== 非聚簇索引为什么不存数据地址值而存储主键?

因为聚簇索引中有时会引发分页操作、重排操作数据有可能会移动

== 什么是覆盖索引?

覆盖索引是指一个索引中包含了查询所需的所有列，在查询过程中不需要回表到原始数据页就能直接返回查询结果的一种索引类型。

通常，当我们在数据库中执行查询时，需要通过索引来快速定位符合条件的数据行。一般情况下，通过索引找到的数据行会包含索引列和其它相关列的引用，然后根据引用回表（或称为回到原始数据页）来获取完整的数据行。这个过程需要进行额外的磁盘访问，增加了查询的成本。

而覆盖索引的特点在于，索引中包含了查询所需的所有列，可以直接从索引中获取到查询结果，而无需回表。这种情况下，查询将会非常高效，减少了磁盘访问次数，提高了查询性能。覆盖索引通常适用于查询只需要返回索引列数据，而不需要读取其他额外数据的情况。

使用覆盖索引可以有效地减少I/O操作，提升查询性能，特别是对于大型数据库和复杂查询来说，其优势更为明显。然而，需要注意的是，在设计覆盖索引时，需要权衡索引大小和查询性能，避免创建过多的索引导致索引维护成本增加。

== 非聚集索引一定回表查询吗?

不一定，只要 B+ 树中包含的字段(创建索引的字段)，覆盖(包含)想要 select 的字段，那么就不会回表查询了。

== 为什么要回表查询?直接存储数据不可以吗?

为了控制非聚簇索引的大小

== 如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查 询了?

不是，InnoDB会生成 `rowid` 辅助回表查询

== 什么是联合索引，组合索引，复合索引?

联合索引、组合索引和复合索引指的都是同一种索引类型，即在一个索引上涵盖多个列的索引。

具体来说，联合索引（也称为组合索引或复合索引）是指在数据库表中创建的一种索引，该索引覆盖了多个列。与单列索引不同，联合索引包含了多个列的值，使得在进行查询时能够更高效地定位到符合条件的数据行。

联合索引的特点与优势包括：

1. 减少磁盘IO操作：对于包含在联合索引中的所有列，数据库只需按照索引顺序进行一次搜索，而不是对每个列单独进行搜索，从而减少了磁盘IO操作次数。
2. 提高查询性能：通过联合索引可以更快地定位到符合查询条件的数据行，提高查询效率。
3. 覆盖查询需求：当联合索引中的列包含了查询所需的全部列时，可以避免回表操作，即使得查询成为覆盖索引。

需要注意的是，创建联合索引时，需要根据实际情况选择合适的列顺序，以满足查询频率高的列放在前面，这样可以更好地利用索引性能。此外，联合索引的列顺序还会影响到某些特定查询的效率，因此对于不同的查询场景，可能需要创建不同的联合索引。

== 复合索引创建时字段顺序不一样使用效果一样吗?

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 c2 和 c3 列的大小进行排序，这个包含两层含义:

* 先把各个记录和页按照 c2 列进行排序。
* 在记录的 c2 列相同的情况下，采用 c3 列进行排序
* B+ 树叶子节点处的记录由 c2列、c3列和主键 c1 列组成。
* 本质上也是二级索引

== 多个索引优先级是如何匹配的?

1. 主键(唯一索引)匹配
2. 全值匹配(单值匹配)
3. 最左前缀匹配
4. 范围匹配
5. 索引扫描
6. 全表扫描

一般性建议

* 对于单键索引，尽量选择过滤性更好的索引(例如:手机号，邮件，身份证)
* 在选择组合索引的时候，过滤性最好的字段在索引字段顺序中，位置越靠前越好。 Ø 选择组合索引时，尽量包含where中更多字段的索引
* 组合索引出现范围查询时，尽量把这个字段放在索引次序的最后面
* 尽量避免造成索引失效的情况

== 什么是唯一索引?

唯一索引是一种用于确保列或列组合中的值在表中是唯一的索引。它类似于普通的索引，但有一个关键区别：唯一索引的值必须是唯一的，不允许重复。

当我们在表中创建一个唯一索引时，数据库系统将会在索引列或列组合上创建索引，并强制要求所有的索引值都是唯一的。这意味着，当我们向表中插入或更新数据时，数据库会自动检查唯一索引，如果要插入或更新的值已经存在于索引中，则会报错或被拒绝。

唯一索引的作用是保证数据的一致性和唯一性，可以有效地防止表中出现重复的数据。它对于那些需要保证某些列或列组合的唯一性的情况非常有用，比如数据库中的主键或唯一约束。

在使用唯一索引时需要注意以下几点：

1. 每个表只能存在一个主键，但可以创建多个唯一索引。
2. 唯一索引可以包含单个列或多个列的组合。
3. 当查询条件涉及到唯一索引列时，可以借助索引来提高查询性能。
4. 加入唯一索引会增加索引的维护和空间消耗。

总之，唯一索引是用于保证表中某些列或列组合唯一性的一种索引类型，能够有效地维护数据的一致性和完整性。

== 唯一索引是否影响性能?

是

== 什么时候使用唯一索引?

业务需求唯一字段的时候，一般不考虑性能问题

业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。

说明:不要以 为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的;另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。

== 什么时候适合创建索引，什么时候不适合创建索引?

适合创建索引

* 频繁作为where条件语句查询字段
* 关联字段需要建立索引
* 排序字段可以建立索引
* 分组字段可以建立索引(因为分组前提是排序)
* 统计字段可以建立索引(如.count(),max())

不适合创建索引

* 频繁更新的字段不适合建立索引
* where，分组，排序中用不到的字段不必要建立索引
* 可以确定表数据非常少不需要建立索引
* 参与 MySQL 函数计算的列不适合建索引

创建索引时避免有如下极端误解:

* 宁滥勿缺。认为一个查询就需要建一个索引。
* 宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。
* 抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。

== 什么是索引下推?

索引下推（Index Pushdown）是一种优化技术，用于数据库查询时对索引进行更进一步的使用，减少不必要的数据访问和处理。

传统的查询优化中，在执行查询时，通常首先使用索引定位到符合查询条件的数据行，然后再对这些数据行进行进一步的过滤和处理。而索引下推的思想是在索引层面进行更多的过滤操作，尽量减少数据行的读取和处理。

具体来说，索引下推是在查询过程中，通过在索引层面处理查询条件，提前过滤掉不满足条件的数据行，以减少对数据页的访问和处理。这种方式可以大大减少磁盘I/O操作量，提高查询性能。

举个例子，假设我们有一个表格，并在其中的一个列上创建了索引。当执行查询时，传统的方式是先通过索引定位到符合条件的索引项，然后再回表（根据索引项找到实际数据行）进行进一步的判断和处理。

而索引下推的方式则在索引层面利用索引上的条件，尽可能地过滤掉不满足条件的索引项，只保留符合条件的索引项，然后再回表获取相应的数据行。这样相比传统方式，可以避免回表的次数，减少磁盘IO操作。

索引下推技术通常由数据库优化器自动选择使用，具体是否能应用索引下推取决于查询的条件、索引的结构和数据库系统的优化器实现。索引下推可以提高查询效率，减少查询的成本，特别是在涉及大量数据页的查询场景下更为明显。

总结:

未开启索引下推时，根据筛选条件在索引树中筛选第一个条件，获得结果集后回表操作，进行其他条件筛选，再次回表查询。

开启索引下推时，在条件查询时，当前索引树如果满足全部筛选条件，可以在当前树中完成全部筛选过滤，得到比较小的结果集再进行回表操作

5.6 之前的版本是没有索引下推这个优化的

== 有哪些情况会导致索引失效?

* 计算、函数导致索引失效
+
[source,sql]
----
-- 显示查询分析
EXPLAIN SELECT * FROM emp WHERE emp.name LIKE 'abc%';
EXPLAIN SELECT * FROM emp WHERE LEFT(emp.name,3) = 'abc'; --索引失效
----
* LIKE 以 %，_ 开头索引失效
+
[source,sql]
----
-- 显示查询分析
EXPLAIN SELECT * FROM emp WHERE name LIKE '%ab%'; --索引失效
----
* 不等于(!= 或者<>)索引失效
+
[source,sql]
----
-- 显示查询分析
EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.name = 'abc' ;
EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.name <> 'abc' ; --索引失效
----
* IS NOT NULL 失效 和 IS NULL
+
[source,sql]
----
-- 显示查询分析
EXPLAIN SELECT * FROM emp WHERE emp.name IS NULL;
EXPLAIN SELECT * FROM emp WHERE emp.name IS NOT NULL; --索引失效
----
+
NOTE: 当数据库中的数据的索引列的 ，即使在 IS NOT NULL 的情况下 MySQL 的查询优化器会选择使用索引，此时 type 的值是 range(范围查询)
+
[source,sql]
----
-- 将 id>20000 的数据的 name 值改为 NULL
UPDATE emp SET `name` = NULL WHERE `id` > 20000;
-- 执行查询分析，可以发现 IS NOT NULL 使用了索引
-- 具体多少条记录的值为NULL可以使索引在IS NOT NULL的情况下生效，由查询优化器的算法决定
EXPLAIN SELECT * FROM emp WHERE emp.name IS NOT NULL
----
* 类型转换导致索引失效
+
[source,sql]
----
EXPLAIN SELECT * FROM emp WHERE name='123';
EXPLAIN SELECT * FROM emp WHERE name= 123; --索引失效
----
* 复合索引未用左列字段失效
* 如果 MySQL 觉得全表扫描更快时(数据少);

== 为什么 LIKE 以 % 开头索引会失效?

有三个字段 `id`,`name`,`age`，其中 `name` 创建索引

[source,sql]
----
EXPLAIN select * from user where name like '%明'
-- type = all
EXPLAIN select name,id from user where name like '%明'
-- type=index
----

其实并不会完全失效，覆盖索引下会出现 `type=index`，表示遍历了索引树，再回表查询， 覆盖索引没有生效的时会直接 `type=all`

没有高效使用索引是因为字符串索引会逐个转换成 ascii 码，生成 B+ 树时按首个字符串顺序排序，类似复合索引未用左列字段失效一样，跳过开始部分也就无法使用生成的 B+ 树了

== 一个表有多个索引的时候，能否手动选择使用哪个索引?

不可用手动直接干预，只能通过 MySQL 优化器自动选择

== 如何查看一个表的索引?

[source,sql]
----
show index from t_emp; // 显示表上的索引
explain select * from t_emp where id=1; // 显示可能会用到的索引及最终使用的索引
----

== 能否查看到索引选择的逻辑?是否使用过 optimizer_trace?

[source,sql]
----
set session optimizer_trace="enabled=on",end_markers_in_json=on;
SELECT * FROM information_schema.OPTIMIZER_TRACE;
set session optimizer_trace="enabled=off";
----

== 使用 Order By 时能否通过索引排序?

没有过滤条件不走索引

== 通过索引排序内部流程是什么?

关键配置:

* sort_buffer: 可供排序的内存缓冲区大小
* max_length_for_sort_data: 单行所有字段总和限制，超过这个大小启动双路排序

. 通过索引检过滤筛选条件索到需要排序的字段+其他字段(如果是符合索引)
. 判断索引内容是否覆盖 select 的字段
.. 如果覆盖索引，select 的字段和排序都在索引上，那么在内存中进行排序，排序后输出结果
.. 如果索引没有覆盖查询字段，接下来计算 select 的字段是否超过 max_length_for_sort_data 限制，如果超过，启动双路排序，否则使用单路

== 什么是双路排序和单路排序

* 单路排序:一次取出所有字段进行排序，内存不够用的时候会使用磁盘
* 双路排序:取出排序字段进行排序，排序完成后再次回表查询所需要的其他字段

如果不在索引列上，filesort 有两种算法: MySQL 就要启动双路排序和单路排序 双路排序(慢)

Select id,age,name from stu order by name;

* MySQL 4.1 之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和 order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出

* 从磁盘取排序字段，在 buffer 进行排序，再从磁盘取其他字段。
* 取一批数据，要对磁盘进行两次扫描，众所周知，I\O 是很耗时的，所以在 MySQL 4.1 之后，出现了第二种改进的算法，就是单路排序。

单路排序(快)

* 从磁盘读取查询需要的所有列，按照 order by 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。

结论及引申出的问题

但是用单路有问题

在 sort_buffer 中，单路比多路要多占用很多空间，因为单路是把所有字段都取出, 所以有可能取出的数 据的总大小超出了 sort_buffer 的容量，导致每次只能取 sort_buffer 容量大小的数据，进行排序(创建 tmp 文件，多路合并)，排完再取 sort_buffer 容量大小，再排......从而多次I/O。
单路本来想省一次 I/O 操作，反而导致了大量的 I/O 操作，反而得不偿失。 优化策略

* 增大 sort_buffer_size 参数的设置
* 增大 max_length_for_sort_data 参数的设置
* 减少 select 后面的查询的字段。 禁止使用select *

提高 Order By 的速度

. Order by 时 select * 是一个大忌。只 Query 需要的字段， 这点非常重要。在这里的影响是:
.. 当 Query 的字段大小总和小于 max_length_for_sort_data 而且排序字段不是 TEXT|BLOB 类型时，会用改进后的算法 - 单路排序， 否则用老算法——多路排序。
两种算法的数据都有可能超出 sort_buffer 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 I/O，但是用单路排序算法的风险会更大一些，所以要提高 sort_buffer_size。
. 尝试提高 sort_buffer_size:
不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对 每个进程(connection)的 1M-8M之间调整。 MySQL5.7 和 8.0，InnoDB 存储引擎默认值是 1048576 字节，1MB。
SHOW VARIABLES LIKE '%sort_buffer_size%';
. 尝试提高 max_length_for_sort_data: 提高这个参数， 会增加用改进算法的概率。 SHOW VARIABLES LIKE '%max_length_for_sort_data%';

5.7默认1024字节，8.0默认 4096 字节。但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大，明显症状是高的磁盘 I/O 活动和低 的处理器使用率。如果需要返回的列的总长度大
于 max_length_for_sort_data，使用双路算法，否则使 用单路算法。1024-8192 字节之间调整

== group by 分组和 order by 在索引使用上有什么区别?

group by 使用索引的原则几乎跟order by一致 ，唯一区别:

* group by 先排序再分组，遵照索引建的最佳左前缀法则
* group by 没有过滤条件，也可以用上索引。Order By 必须有过滤条件才能使用上索引。

== 如果表中有字段为 null，又被经常查询该不该给这个字段创建索引?

应该创建索引，使用的时候尽量使用 is null 判断。

IS NOT NULL 失效 和 IS NULL

[source,sql]
----
EXPLAIN SELECT * FROM emp WHERE emp.name IS NULL;
EXPLAIN SELECT * FROM emp WHERE emp.name IS NOT NULL; --索引失效
----

[NOTE]
====
当数据库中的数据的索引列的 NULL 值达到比较高的比例的时候 ，即使在 IS NOT NULL 的情况下 MySQL 的查询优化器会选择使用索引， 此时 type 的值是 range(范围查询)
====

[source,sql]
----
-- 将 id>20000 的数据的 name 值改为 NULL
UPDATE emp SET `name` = NULL WHERE `id` > 20000;
-- 执行查询分析，可以发现 IS NOT NULL 使用了索引
-- 具体多少条记录的值为NULL可以使索引在IS NOT NULL的情况下生效，由查询优化器的算法决定 EXPLAIN SELECT * FROM emp WHERE emp.name IS NOT NULL
----

== 有字段为 null 索引是否会失效?

不一定会失效，每一条 SQL 具体有没有使用索引 可以通过 trace 追踪一下 最好还是给上默认值

数字类型的给 0，字符串给个空串“”，
