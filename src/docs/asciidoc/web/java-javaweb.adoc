[[guide-web]]
= java Web

[[guide-web-1]]
== XML 文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？

XML 文档定义分为 DTD 和 Schema 两种形式,二者都是对 XML 语法的约束,其本质区别在于 Schema 本身也是一个 XML 文件，可以被 XML 解析器解析，而且可以为 XML 承载的数据定义类型，约束能力较之 DTD 更强大。
对 XML 的解析主要有 DOM(文档对象模型,Document Object Model)、SAX(Simple API for XML)和 StAX(Java 6 中引入的新的解析 XML 的方式,Streaming API for XML)，
其中 DOM 处理大型文件时其性能下降的非常厉害,这个问题是由 DOM 树结构占用的内存较多造成的,而且 DOM 解析方式必须在解析文件之前把整个文档装入内存，
适合对 XML 的随机访问(典型的用空间换取时间的策略);SAX 是事件驱动型的 XML 解析方式,它顺序读取 XML 文件,不需要一次全部装载整个文件。
当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件,用户通过事件回调代码来处理 XML 文件,适合对 XML 的顺序访问。
顾名思义,StAX 把重点放在流上,实际上 StAX 与其他解析方式的本质区别就在于应用程序能够把 XML 作为一个事件流来处理。
将 XML 作为一组事件来处理的想法并不新颖(SAX 就是这样做的),但不同之处在于 StAX 允许应用程序代码把这些事件逐个拉出来,而不用提供在解析器方便时从解析器中接收事件的处理程序。

[[guide-web-2]]
== 你在项目中哪些地方用到了 XML？


XML 的主要作用有两个方面:数据交换和信息配置.在做数据交换时,XML 将数据用标签组装成起来,然后压缩打包加密后通过网络传送给接收者,接收解密与解压缩后再从 XML 文件中还原相关信息进行处理.

XML 曾经是异构系统间交换数据的事实标准,但此项功能几乎已经被 JSON(JavaScript Object Notation)取而代之.当然,目前很多软件仍然使用XML来存储配置信息,我们在很多项目中通常也会将作为配置信息的硬代码写在 XML 文件中，Java 的很多框架也是这么做的,而且这些框架都选择了 dom4j 作为处理 XML 的工具，
因为 Sun 公司的官方 API 实在不怎么好用.

补充:现在有很多时髦的软件(如 Sublime)已经开始将配置文件书写成 JSON 格式,我们已经强烈的感受到 XML 的另一项功能也将逐渐被业界抛弃.

[[guide-web-7]]
== 事务的 ACID 是指什么？

* 原子性(Atomic):事务中各项操作,要么全做要么全不做,任何一项操作的失败都会导致整个事务的失败
* 一致性(Consistent):事务结束后系统状态是一致的;
* 隔离性(Isolated):并发执行的事务彼此无法看到对方的中间状态;
* 持久性(Durable):事务完成后所做的改动都会被持久化,即使发生灾难性的失败.通过日志和同步备份可以在故障发生后重建数据.

补充:关于事务,在面试中被问到的概率是很高的,可以问的问题也是很多的.首先需要知道的是,只有存在并发数据访问时才需要事务.当多个事务访问同一数据时,可能会存在 5 类问题,包括 3 类数据读取问题(脏读、不可重复读和幻读)和 2 类数据更新问题(第 1 类丢失更新和第 2 类丢失更新).

* 脏读(Dirty Read):A 事务读取 B 事务尚未提交的数据并在此基础上操作,而B事务执行回滚,那么 A 读取到的数据就是脏数据.

[[guide-web-7-tbl]]
.脏读
|===
| 时间 | 转账事务A                   | 取款事务B

| T1   |                             | 开始事务

| T2   | 开始事务                    |

| T3   |                             | 查询账户余额为1000元

| T4   |                             | 取出500元余额修改为500元

| T5   | 查询账户余额为500元(脏读) |

| T6   |                            | 撤销事务余额恢复为1000元

| T7   | 汇入100元把余额修改为600元 |

| T8   | 提交事务                   |
|===

* 不可重复读(Unrepeatable Read):事务 A 重新读取前面读取过的数据,发现该数据已经被另一个已提交的事务 B 修改过了.

[[guide-web-7-2-tbl]]
.不可重复读
|===
| 时间 | 转账事务A                   | 取款事务B

| T1   |                             | 开始事务

| T2   | 开始事务                    |

| T3   |                             | 查询账户余额为1000元

| T4   |       查询账户余额为1000元                      |

| T5   |  |        取出100元修改余额为900元

| T6   |  |        提交事务

| T7   | 查询账户余额为900元(不可重复读) |
|===

* 幻读(Phantom Read):事务 A 重新执行一个查询,返回一系列符合查询条件的行,发现其中插入了被事务 B 提交的行.
** 第1类丢失更新:事务 A 撤销时,把已经提交的事务 B 的更新数据覆盖了.
+
[[guide-web-7-3-tbl]]
|===
| 时间 | 统计金额事务A                   | 转账事务B

| T1   |                             | 开始事务

| T2   | 开始事务                    |

| T3   |  统计总存款为 10000 元                           |

| T4   |                         | 新增一个存款账户存入 100 元

| T5   |  |        提交事务

| T6   |  |       再次统计总存款为 10100 元(幻读)
|===

* 第2类丢失更新:事务 A 覆盖事务 B 已经提交的数据,造成事务 B 所做的操作丢失.

[[guide-web-7-4-tbl]]
|===
| 时间 | 转账事务A              | 取款事务B

| T1   |                             |     开始事务

| T2   |       开始事务              |

| T3   |                             | 查询账户余额为 1000 元

| T4   |         查询账户余额为 1000 元                |

| T5   |  |        取出 100 元将余额修改为 900 元

| T6   |  |       提交事务

| T7   |  汇入 100 元将余额修改为 1100 元|

| T8   |  提交事务|

| T9   |  查询账户余额为 1100 元(丢失更新)|
|===

数据并发访问所产生的问题,在有些场景下可能是允许的,但是有些场景下可能就是致命的,数据库通常会通过锁机制来解决数据并发访问问题,按锁定对象不同可以分为表级锁和行级锁。
按并发事务锁定关系可以分为共享锁和独占锁,具体的内容大家可以自行查阅资料进行了解.直接使用锁是非常麻烦的,为此数据库为用户提供了自动锁机制,只要用户指定会话的事务隔离级别，
数据库就会通过分析 SQL 语句然后为事务访问的资源加上合适的锁,此外,数据库还会维护这些锁通过各种手段提高系统的性能,这些对用户来说都是透明的(就是说你不用理解,事实上我确实也不知道)。
ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别,如下表所示:

[[guide-web-7-5-tbl]]
|===
| 隔离级别        | 脏读   | 不可重复读 | 幻读   | 第一类丢失更新 | 第二类丢失更新

| READ UNCOMMITED | 允许   | 允许       | 允许   | 不允许         | 允许

| READ COMMITTED  | 不允许 | 允许       | 允许   | 不允许         | 允许

| REPEATABLE READ | 不允许 | 不允许     | 允许   | 不允许         | 不允许

| SERIALIZABLE    | 不允许 | 不允许     | 不允许 |                | 不允许
|===

需要说明的是,事务隔离级别和数据访问的并发性是对立的,事务隔离级别越高并发性就越差.所以要根据具体的应用来确定合适的事务隔离级别,这个地方没有万能的原则.

[[guide-web-12]]
== JSP 有哪些内置对象？作用分别是什么？

JSP 有 9 个内置对象:

* request:封装客户端的请求,其中包含来自GET或POST请求的参数;
* response:封装服务器对客户端的响应;
* pageContext:通过该对象可以获取其他对象;
* session:封装用户会话的对象;
* application:封装服务器运行环境的对象;
* out:输出服务器响应的输出流对象;
* config:Web应用的配置对象;
* page:JSP页面本身(相当于Java程序中的this);
* exception:封装页面抛出异常的对象.

补充:如果用 Servlet 来生成网页中的动态内容无疑是非常繁琐的工作,另一方面,所有的文本和 HTML 标签都是硬编码,即使做出微小的修改,都需要进行重新编译。
JSP 解决了 Servlet 的这些问题,它是 Servlet 很好的补充,可以专门用作为用户呈现视图(View),而 Servlet 作为控制器(Controller)专门负责处理用户请求并转发或重定向到某个页面。

基于 Java的Web 开发很多都同时使用了 Servlet 和 JSP.JSP 页面其实是一个 Servlet,能够运行 Servlet 的服务器(Servlet 容器)通常也是 JSP 容器,可以提供 JSP 页面的运行环境，
Tomcat 就是一个 Servlet/JSP 容器.第一次请求一个 JSP 页面时,Servlet/JSP 容器首先将 JSP 页面转换成一个 JSP 页面的实现类,这是一个实现了 JspPage 接口或其子接口 HttpJspPage 的 Java 类。
JspPage 接口是 Servlet 的子接口,因此每个 JSP 页面都是一个 Servlet.转换成功后,容器会编译 Servlet 类,之后容器加载和实例化 Java 字节码,并执行它通常对 Servlet 所做的生命周期操作。
对同一个 JSP 页面的后续请求,容器会查看这个 JSP 页面是否被修改过,如果修改过就会重新转换并重新编译并执行.如果没有则执行内存中已经存在的 Servlet 实例。
我们可以看一段 JSP 代码对应的 Java 程序就知道一切了,而且 9 个内置对象的神秘面纱也会被揭开。

JSP 页面:

[source,jsp]
----
<%@ page pageEncoding="UTF-8"%>
<%
String path = request.getContextPath();
String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";
%>
<!DOCTYPE html>
<html>
    <head>
        <base href="<%=basePath%>">
        <title>首页</title>
        <style type="text/css">
            * { font-family: "Arial"; }
        </style>
    </head>
    <body>
        <h1>Hello, World!</h1>
        <hr/>
        <h2>Current time is: <%= new java.util.Date().toString() %></h2>
    </body>
</html>
----


对应的 Java 代码:

[source,java]
----
/*
* Generated by the Jasper component of Apache Tomcat
* Version: Apache Tomcat/7.0.52
* Generated at: 2014-10-13 13:28:38 UTC
* Note: The last modified time of this file was set to
* the last modified time of the source file after
* generation to assist with modification tracking.
*/
package org.apache.jsp;
import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;
public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase
implements org.apache.jasper.runtime.JspSourceDependent {
    private static final javax.servlet.jsp.JspFactory _jspxFactory =javax.servlet.jsp.JspFactory.getDefaultFactory();
    private static java.util.Map<java.lang.String, java.lang.Long> _jspx_dependants;
    private javax.el.ExpressionFactory _el_expressionfactory;
    private org.apache.tomcat.InstanceManager _jsp_instancemanager;

    public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
        return _jspx_dependants;
    }

    public void _jspInit() {
        _el_expressionfactory = _jspxFactory.getJspApplicationContext(
        getServletConfig().getServletContext()).getExpressionFactory();
        _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory
        .getInstanceManager(getServletConfig());
    }

    public void _jspDestroy() {
    }

    public void _jspService(
    final javax.servlet.http.HttpServletRequest request,
    final javax.servlet.http.HttpServletResponse response)
    throws java.io.IOException, javax.servlet.ServletException {
        // 内置对象就是在这里定义的
        final javax.servlet.jsp.PageContext pageContext;
        javax.servlet.http.HttpSession session = null;
        final javax.servlet.ServletContext application;
        final javax.servlet.ServletConfig config;
        javax.servlet.jsp.JspWriter out = null;
        final java.lang.Object page = this;
        javax.servlet.jsp.JspWriter _jspx_out = null;
        javax.servlet.jsp.PageContext _jspx_page_context = null;
        try {
            response.setContentType("text/html;charset=UTF-8");
            pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true);
            _jspx_page_context = pageContext;
            application = pageContext.getServletContext();
            config = pageContext.getServletConfig();
            session = pageContext.getSession();
            out = pageContext.getOut();
            _jspx_out = out;
            out.write('\r');
            out.write('\n');
            String path = request.getContextPath();
            String basePath = request.getScheme() + "://"
            + request.getServerName() + ":" + request.getServerPort()
            + path + "/";
            // 以下代码通过输出流将HTML标签输出到浏览器中
            out.write("\r\n");
            out.write("\r\n");
            out.write("<!DOCTYPE html>\r\n");
            out.write("<html>\r\n");
            out.write(" <head>\r\n");
            out.write(" <base href=\"");
            out.print(basePath);
            out.write("\">\r\n");
            out.write(" <title>首页</title>\r\n");
            out.write(" <style type=\"text/css\">\r\n");
            out.write(" \t* { font-family: \"Arial\"; }\r\n");
            out.write(" </style>\r\n");
            out.write(" </head>\r\n");
            out.write(" \r\n");
            out.write(" <body>\r\n");
            out.write(" <h1>Hello, World!</h1>\r\n");
            out.write(" <hr/>\r\n");
            out.write(" <h2>Current time is: ");
            out.print(new java.util.Date().toString());
            out.write("</h2>\r\n");
            out.write(" </body>\r\n");
            out.write("</html>\r\n");
        } catch (java.lang.Throwable t) {
            if (!(t instanceof javax.servlet.jsp.SkipPageException)) {
            out = _jspx_out;
            if (out != null && out.getBufferSize() != 0)
            try {
				out.clearBuffer();
            } catch (java.io.IOException e) {
            }
            if (_jspx_page_context != null)
                _jspx_page_context.handlePageException(t);
            else throw new ServletException(t);
            }
		} finally {
            _jspxFactory.releasePageContext(_jspx_page_context);
		}
    }
}
----

== Http 常见的状态码有哪些？

* 200 OK //客户端请求成功
* 301 Moved Permanently（永久移除)，请求的 URL 已移走。Response 中应该包含一个 Location URL, 说明资源现在所处的位置
* 302 found 重定向
* 400 Bad Request //客户端请求有语法错误，不能被服务器所理解
* 401 Unauthorized //请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用
* 403 Forbidden //服务器收到请求，但是拒绝提供服务
* 404 Not Found //请求资源不存在，eg：输入了错误的 URL
* 500 Internal Server Error //服务器发生不可预期的错误
* 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常

[[guide-web-13]]
== get 和 post 请求的区别？

* GET 请求的数据会附在 URL 之后（就是把数据放置在 HTTP 协议头中），以?分割 URL 和传输数据，参数
之间以&相连，如：login.action?name=zhagnsan&password=123456。POST 把提交的数据则放置在是 HTTP 包的包
体中。
* GET 方式提交的数据最多只能是 1024 字节，理论上 POST 没有限制，可传较大量的数据。其实这样说是错
误的，不准确的：“GET 方式提交的数据最多只能是 1024 字节"，因为 GET 是通过 URL 提交数据，那么 GET 可
提交的数据量就跟 URL 的长度有直接关系了。而实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对
URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。 IE 对 URL 长度的限制是 2083 字节(2K+35)。
对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。
* POST 的安全性要比 GET 的安全性高。注意：这里所说的安全性和上面 GET 提到的“安全”不是同个概念。
上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的 Security 的含义，比如：通过 GET 提交数据，用户名和密码将明文出现在 URL 上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，
那么别人就可以拿到你的账号和密码了，除此之外，使用 GET 提交数据还可能会造成 Cross-site request forgery 攻
击。
* Get 是向服务器发索取数据的一种请求，而 Post 是向服务器提交数据的一种请求，在 FORM（表单）中，Method 默认为"GET"，实质上，GET 和 POST 只是发送机制不同，并不是一个取一个发！

[[guide-web-40]]
== Cookie 和 Session 的区别

. Session 是存储在服务器端, Cookie 是存储在客户端的,所以从安全来讲 Session 的安全性要比 Cookie 高.
. 单个 Cookie 保存的数据不能超过 `4K`,很多浏览器都限制一个站点最多保存 20 个 Cookie ,而 Session  Session 是存放在服务器的内存中,所以 Session 里的东西不断增加会造成服务器的负担,所以一般把很重要的信息才存储在 Session 中,而把一些次要东西存储在客户端的 Cookie 里(例如将登陆信息等重要信息存放为 Session ,其他信息如果需要保留,可以放在 Cookie )
*  Cookie 分为两大类分为会话 Cookie 和持久化 Cookie ,会话 Cookie ,存放在客户端浏览器的内存中,他的生命周期和浏览器是一致的,浏览器关了会话 Cookie 也就消失了,而持久化 Cookie 是存放在客户端硬盘中,而持久化 Cookie 的生命周期就是我们在设置 Cookie 时候设置的那个保存时间
* 当浏览器关闭时 Session 会不会丢失, Session 的信息是通过会话 Cookie 的 Session id获取的,当浏览器关闭的时候会话 Cookie 消失,所以我们的 Session id也就消失了,但是 Session 的信息还存在服务器端,这时我们只是查不到所谓的 Session 但它并不是不存在.
*  Session 在什么情况下丢失,就是在服务器关闭的时候(也可以说说 Session 的活化和钝化),或者是 Session 过期(默认时间是 30 分钟),再或者调用了 `invalidate()` 的或者是我们想要 Session 中的某一条数据消失调用 ``Session.removeAttribute()``方法
*  Session 在什么时候被创建呢,确切的说是通过调用 getSession() 来创建.访问 HTML 页面是不会创建  Session  ,但是访问index.JSP时会创建 Session (JSP 实际上是一个 Servlet,Servlet 中有 getSession 方法).

[[guide-web-14]]
== 常用的 Web 服务器有哪些？

Unix 和 Linux 平台下使用最广泛的免费 HTTP 服务器是 Apache 服务器,而 Windows 平台的服务器通常使用 IIS 作为 Web 服务器。
选择 Web 服务器应考虑的因素有:性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等.下面是对常见服务器的简介:

* IIS:Microsoft 的 Web 服务器产品,全称是Internet Information Services.IIS是允许在公共 Intranet 或 Internet 上发布信息的 Web 服务器。IIS 是目前最流行的Web服务器产品之一,很多著名的网站都是建立在 IIS 的平台上。
IIS 提供了一个图形界面的管理工具,称为 Internet 服务管理器,可用于监视配置和控制 Internet 服务。
IIS 是一种 Web 服务组件,其中包括 Web 服务器、FTP 服务器、NNTP 服务器和 SMTP 服务器,分别用于网页浏览、文件传输、新闻服务和邮件发送等方面,它使得在网络(包括互联网和局域网)上发布信息成了一件很容易的事。
它提供 ISAPI(Intranet Server API)作为扩展Web服务器功能的编程接口;同时,它还提供一个 Internet 数据库连接器,可以实现对数据库的查询和更新.
* Kangle:Kangle Web 服务器是一款跨平台、功能强大、安全稳定、易操作的高性能 Web 服务器和反向代理服务器软件.此外,Kangle 也是一款专为做虚拟主机研发的Web服务器.实现虚拟主机独立进程、独立
身份运行.用户之间安全隔离,一个用户出问题不影响其他用户.支持 PHP、ASP、ASP.NET、Java、Ruby 等多种动态开发语言.
* WebSphere:WebSphere Application Server 是功能完善、开放的 Web 应用程序服务器,是IBM电子商务计划的核心部分,它是基于 Java 的应用环境,用于建立、部署和管理 Internet 和 Intranet Web 应用程序,
适应各种 Web 应用程序服务器的需要.
* WebLogic:WebLogic Server 是一款多功能、基于标准的Web应用服务器,为企业构建企业应用提供了坚实的基础.针对各种应用开发、关键性任务的部署,各种系统和数据库的集成、跨 Internet 协作等 Weblogic 都提
供了相应的支持.由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发等优势,很多公司的企业级应用都选择它来作为开发和部署的环境.WebLogic Server 在使应用服务器成为企业应用
架构的基础方面一直处于领先地位,为构建集成化的企业级应用提供了稳固的基础.
* Apache:目前 Apache 仍然是世界上用得最多的 Web 服务器,其市场占有率很长时间都保持在 60% 以上(目前的市场份额约40%左右).世界上很多著名的网站都是 Apache 的产物,它的成功之处主要在
于它的源代码开放、有一支强大的开发团队、支持跨平台的应用(可以运行在几乎所有的 Unix、Windows、Linux 系统平台上)以及它的可移植性等方面.
* Tomcat:Tomcat 是一个开放源代码、运行 Servlet 和 JSP 的容器.Tomcat 实现了 Servlet 和 JSP 规范.此外,Tomcat 还实现了 Apache-Jakarta 规范而且比绝大多数商业应用软件服务器要好,因此目前也有不少的 Web 服务器都选择了 Tomcat.
* Nginx:读作 "engine x",是一个高性能的 HTTP 和反向代理服务器,也是一个 IMAP/POP3/SMTP 代理服务器.Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler 站点开发的,第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日.其将源代码以类 BSD 许可证的形式发布,因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。
在 2014 年 下半年,Nginx 的市场份额达到了 14%.

[[guide-web-16]]
== 讲解 JSP 中的四种作用域.

JSP 中的四种作用域包括 page、request、 Session 和 application,具体来说:

* page 代表与一个页面相关的对象和属性.
* request代表与Web客户机发出的一个请求相关的对象和属性.一个请求可能跨越多个页面,涉及多个Web组件;需要在页面显示的临时数据可以置于此作用域.
* Session 代表与某个用户与服务器建立的一次会话相关的对象和属性.跟某个用户相关的数据应该放在用户自己的 Session 中.
* application 代表与整个 Web 应用程序相关的对象和属性,它实质上是跨越整个 Web 应用程序,包括多个页面、请求和会话的一个全局作用域.

[[guide-web-18]]
== 实现会话跟踪的技术有哪些

由于 HTTP 协议本身是无状态的,服务器为了区分不同的用户,就需要对用户会话进行跟踪,简单的说就是为用户进行登记,为用户分配唯一的ID,下一次用户在请求中包含此ID,服务器据此判断到底是哪一个用户.

* URL 重写:在 URL 中添加用户会话的信息作为请求的参数,或者将唯一的会话 ID 添加到 URL 结尾以标识一个会话.
* 设置表单隐藏域:将和会话跟踪相关的字段添加到隐式表单域中,这些信息不会在浏览器中显示但是提交表单时会提交给服务器.这两种方式很难处理跨越多个页面的信息传递,因为如果每次都要修改 URL 或在页面中添加隐
式表单域来存储用户会话相关信息,事情将变得非常麻烦.
* cookie: Cookie 有两种,一种是基于窗口的,浏览器窗口关闭后, Cookie 就没有了;另一种是将信息存储在一个临时文件中,并设置存在的时间.当用户通过浏览器和服务器建立一次会话后,会话 ID 就会随响应
信息返回存储在基于窗口的 Cookie 中,那就意味着只要浏览器没有关闭,会话没
有超时,下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份.会话中可以为用户保存信息.会话对象是在服务器内存中的,而基于窗口的 Cookie 是在客户端内存中的.如果浏览器禁用了cookie,那么就需要
通过下面两种方式进行会话跟踪.当然,在使用 Cookie 时要注意几点:首先不要在 Cookie 中存放敏感信息;其次 Cookie 存储的数据量有限(4k),不能将过多的内容存储 Cookie 中;再者浏览器通常只允许
一个站点最多存放 20 个 Cookie .当然,和用户会话相关的其他信息(除了会话ID)也可以存在 Cookie 方便进行会话跟踪.
* HttpSession:在所有会话跟踪技术中,HttpSession 对象是最强大也是功能最多的.当一个用户第一次访问某个网站时会自动创建 HttpSession,每个用户可以访问他自己的 HttpSession.可以通
过 HttpServletRequest 对象的 getSession 方法获得 HttpSession,通过 HttpSession 的 setAttribute 方法可以将一个值放在 HttpSession 中,通过调用 HttpSession 对象的 getAttribute 方法,同
时传入属性名就可以获取保存在 HttpSession 中的对象.与上面三种方式不同的是,HttpSession 放在服务器的内存中,因此不要将过大的对象放在里面,即使目前的 Servlet 容器可以在内存将满时将 HttpSession 中的
对象移到其他存储设备中,但是这样势必影响性能.添加到 HttpSession 中的值可以是任意 Java 对象,这个对象最好实现了 Serializable 接口,这样 Servlet 容器在必要的时候可以将其序列化
到文件中,否则在序列化时就会出现异常.

**补充:** HTML5 中可以使用 WebStorage 技术通过 JavaScript 来保存数据,例如可以使用 localStorage 和 sessionStorage 来保存用户会话的信息,也能够实现会话跟踪

[[guide-web-22]]
== 你的项目中使用过哪些JSTL标签？

项目中主要使用了 JSTL 的核心标签库,包括 `<c:if>、<c:choose>、<c: when>、<c: otherwise>、<c:forEach>` 等,主要用于构造循环和分支结构以控制显示逻辑.

说明:虽然 JSTL 标签库提供了 core、sql、fmt、xml 等标签库,但是实际开发中建议只使用核心标签库(core),而且最好只使用分支和循环标签并辅以表达式语言(EL),这样才能真正做到数
据显示和业务逻辑的分离,这才是最佳实践.

[[guide-web-23]]
== 使用标签库有什么好处？如何自定义 JSP 标签？

* 分离 JSP 页面的内容和逻辑,简化了 Web 开发;
* 开发者可以创建自定义标签来封装业务逻辑和显示逻辑;
* 标签具有很好的可移植性、可维护性和可重用性;
* 避免了对 Scriptlet(小脚本)的使用(很多公司的项目开发都不允许在 JSP 中书写小脚本)

自定义 JSP 标签包括以下几个步骤:

. 编写一个 Java 类实现实现 `Tag/BodyTag/IterationTag` 接口(开发中通常不直接实现这些接口而是继承 `TagSupport/BodyTagSupport/SimpleTagSupport` 类,这是对缺省适配模式的应用)
. 重写 `doStartTag()`、`doEndTag()` 等方法,定义标签要完成的功能
. 编写扩展名为 tld 的标签描述文件对自定义标签进行部署,`tld` 文件通常放在 `WEB-INF` 文件夹下或其子目录中

- 在 JSP 页面中使用 taglib 指令引用该标签库.


下面是一个自定义标签库的例子.

步骤1 - 标签类源代码 TimeTag.java:

[source,java]
----
package com.jackfrued.tags;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import javax.servlet.jsp.JspException;
import javax.servlet.jsp.JspWriter;
import javax.servlet.jsp.tagext.TagSupport;
public class TimeTag extends TagSupport {
    private static final long serialVersionUID = 1L;
    private String format = "yyyy-MM-dd hh:mm:ss";
    private String foreColor = "black";
    private String backColor = "white";
    public int doStartTag() throws JspException {
        SimpleDateFormat sdf = new SimpleDateFormat(format);
        JspWriter writer = pageContext.getOut();
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("<span style='color:%s;background-color:%s'>%s</span>",
                                foreColor, backColor, sdf.format(new Date())));
        try {
            writer.print(sb.toString());
        } catch(IOException e) {
            e.printStackTrace();
        }
        return SKIP_BODY;
    }
    public void setFormat(String format) {
        this.format = format;
    }
    public void setForeColor(String foreColor) {
        this.foreColor = foreColor;
    }
    public void setBackColor(String backColor) {
        this.backColor = backColor;
    }
}
----

步骤2 - 编写标签库描述文件 my.tld:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8" ?>
<taglib xmlns="http://java.sun.com/xml/ns/j2ee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
                            http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"
        version="2.0">
    <description>定义标签库</description>
    <tlib-version>1.0</tlib-version>
    <short-name>MyTag</short-name>
    <tag>
        <name>time</name>
        <tag-class>com.jackfrued.tags.TimeTag</tag-class>
        <body-content>empty</body-content>
        <attribute>
            <name>format</name>
            <required>false</required>
        </attribute>
        <attribute>
            <name>foreColor</name>
        </attribute>
        <attribute>
            <name>backColor</name>
        </attribute>
    </tag>
</taglib>
----

步骤3 - 在 JSP 页面中使用自定义标签:

[source,jsp]
----
<%@ page pageEncoding="UTF-8"%>
<%@ taglib prefix="my" uri="/WEB-INF/tld/my.tld" %>
<%
String path = request.getContextPath();
String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";
%>
<!DOCTYPE html>
<html>
    <head>
        <base href="<%=basePath%>">
        <title>首页</title>
        <style type="text/css">
            * { font-family: "Arial"; font-size:72px; }
        </style>
    </head>
    <body>
        <my:time format="yyyy-MM-dd" backColor="blue" foreColor="yellow"/>
    </body>
</html>
----

提示:如果要将自定义的标签库发布成 JAR 文件,需要将标签库描述文件(tld 文件)放在 JAR 文件的 META-INF 目录下,可以 JDK 中的 jar 工具完成 JAR 文件的生成.

[[guide-web-24]]
== 说一下表达式语言(EL)的隐式对象及其作用

EL 的隐式对象包括:pageContext、initParam(访问上下文参数)、param(访问请求参数)、paramValues、header(访问请求头)、headerValues、 Cookie (访问 Cookie )、applicationScope(访问 application 作用域)、sessionScope(访问 session 作用域)、requestScope(访问 request 作用域)、pageScope(访问 page 作用域).

用法如下所示:

* ${pageContext.request.method}
* ${pageContext["request"]["method"]}
* ${pageContext.request["method"]}
* ${pageContext["request"].method}
* ${initParam.defaultEncoding}
* ${header["accept-language"]}
* ${headerValues["accept-language"][0]}
* ${cookie.jsessionid.value}
* ${sessionScope.loginUser.username}

补充:表达式语言的 `.` 和 `[]` 运算作用是一致的,唯一的差别在于如果访问的属性名不符合 Java 标识符命名规则,例如上面的 `accept-language` 就不是一个有效的 Java 标识符,
那么这时候就只能用 `[]` 运算符而不能使用.运算符获取它的值

[[guide-web-25]]
== 表达式语言(EL)支持哪些运算符？


除了 `.` 和 `[]` 运算符,EL 还提供了:

* 算术运算符:+、-、*、/或div、%或mod
* 关系运算符:==或eq、!=或ne、>或gt、>=或ge、<或lt、<=或le
* 逻辑运算符:&&或and、||或or、!或not
* 条件运算符:${statement? A : B}(跟 Java 的条件运算符类似)
* empty 运算符:检查一个值是否为null或者空(数组长度为0或集合中没有元素也返回true)

[[guide-web-26]]
== Java Web 开发的 Model 1 和 Model 2 分别指的是什么？

Model 1 是以页面为中心的 Java Web 开发,使用 JSP+JavaBean 技术将页面显示逻辑和业务逻辑处理分开,JSP 实现页面显示,JavaBean 对象用来保存数据和实现业务逻辑.Model 2 是基于
MVC(模型-视图-控制器,Model-View-Controller)架构模式的开发模型,实现了模型和视图的彻底分离,利于团队开发和代码复用,如下图所示.

image::{oss-images}/guide-3.jpg[]

[[guide-web-28]]
== 如何在基于 Java 的 Web 项目中实现文件上传和下载？

在 Servlet 3 以前,Servlet API 中没有支持上传功能的 API,因此要实现上传功能需要引入第三方工具从 POST 请求中获得上传的附件或者通过自行处理输入流来获得上传的文件,我们推荐使用 Apache 的 commons-fileupload 从 Servlet 3 开始,文件上传变得无比简单,相信看看下面的例子一切都清楚了.

上传页面 index.jsp:

[source,jsp]
----
<%@ page pageEncoding="utf-8"%>
<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Photo Upload</title>
    </head>
    <body>
        <h1>Select your photo and upload</h1>
        <hr/>
        <div style="color:red;font-size:14px;">${hint}</div>
        <form action="UploadServlet" method="post" enctype="multipart/form-data">
            Photo file: <input type="file" name="photo" />
            <input type="submit" value="Upload" />
        </form>
    </body>
</html>
----

支持上传的 Servlet:

[source,java]
----
package com.jackfrued.servlet;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.Part;
@WebServlet("/UploadServlet")
@MultipartConfig
public class UploadServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
    protected void doPost(HttpServletRequest request,
                          HttpServletResponse response) throws ServletException, IOException {
        // 可以用request.getPart()方法获得名为photo的上传附件
        // 也可以用request.getParts()获得所有上传附件(多文件上传)
        // 然后通过循环分别处理每一个上传的文件
        Part part = request.getPart("photo");
        if (part != null && part.getSubmittedFileName().length() > 0) {
            // 用ServletContext对象的getRealPath()方法获得上传文件夹的绝对路径
            String savePath = request.getServletContext().getRealPath("/upload");
            // Servlet 3.1规范中可以用Part对象的getSubmittedFileName()方法获得上传的文件名
            // 更好的做法是为上传的文件进行重命名(避免同名文件的相互覆盖)
            part.write(savePath + "/" + part.getSubmittedFileName());
            request.setAttribute("hint", "Upload Successfully!");
        } else {
            request.setAttribute("hint", "Upload failed!");
        }
        // 跳转回到上传页面
        request.getRequestDispatcher("index.jsp").forward(request, response);
    }
}
----

[[guide-web-30]]
== JSP 中的静态包含和动态包含有什么区别？


静态包含是通过 JSP 的 `include` 指令包含页面,动态包含是通过 JSP 标准动作 `<jsp:forward>` 包含页面.静态包含是编译时包含,如果包含的页面不存在则会产生编译错误,而且
两个页面的 "contentType" 属性应保持一致,因为两个页面会合二为一,只产生一个 class 文件,
因此被包含页面发生的变动再包含它的页面更新前不会得到更新.动态包含是运行时包含,可以向被包含的页面传递参数,包含页面和被包含页面是
独立的,会编译出两个 class 文件,如果被包含的页面不存在,不会产生编译错误,也不影响页面其他部分的执行.代码如下所示:

[source,jsp]
----
<%-- 静态包含--%>
<%@ include file="..." %>
<%-- 动态包含--%>
<jsp:include page="...">
    <jsp:param name="..." value="..." />
</jsp:include>
----

[[guide-web-33]]
== 如何设置请求的编码以及响应内容的类型？

通过请求对象(ServletRequest)的 `setCharacterEncoding(String)` 方法可以设置请求的编码,其实要彻底解决乱码问题就应该让页面、服务器、请求和响应、Java 程序都使用统一的编码,最好的选择当然是 UTF-8;通过
响应对象(ServletResponse)的 `setContentType(String)` 方法可以设置响应内容的类型,当然也可以通过
`HttpServletResponse` 对象的 `setHeader(String, String)` 方法来设置.

说明:现在如果还有公司在面试的时候问 JSP 的声明标记、表达式标记、小脚本标记这些内容的话,这样的公司也不用去了,其实 JSP 内置对象、JSP 指令这些东西基本上都可以忘却了,关于 Java Web 开发的相关知
识,可以看一下《Servlet&JSP思维导图》,上面有完整的知识点的罗列.想了解如何实现自定义 MVC 框架的,可以看一下《Java Web 自定义 MVC 框架详解》.

[[guide-web-34]]
== 解释一下网络应用的模式及其特点.

典型的网络应用模式大致有三类:B/S、C/S、P2P.其中B代表浏览器(Browser)、C代表客户端(Client)、S代表服务器(Server),P2P 是对等模式,不区分客户端和服务器.
B/S应用模式中可以视为特殊的 C/S 应用模式,只是将 C/S 应用模式中的特殊的客户端换成了浏览器,因为几乎所有的系统上都有浏览器,那么只要打开浏览器就可以使用应用,没
有安装、配置、升级客户端所带来的各种开销.P2P应用模式中,成千上万台彼此连接的计算机都处于对等的地位,整个网络一般来说不依赖专用的集中服务器.网络中的每
一台计算机既能充当网络服务的请求者,又对其它计算机的请求作出响应,提供资源和服务.通常这些资源和服务包括:信息的共享和交换、计算资源(如 CPU 的共享)、存储
共享(如缓存和磁盘空间的使用)等,这种应用模式最大的阻力安全性、版本等问题,目前有很多应用都混合使用了多种应用模型,最常见的网络视频应用,它几乎把三种模式都用上了.

补充:此题要跟"电子商务模式"区分开,因为有很多人被问到这个问题的时候马上想到的是 B2B(如阿里巴巴)、B2C(如当当、亚马逊、京东)、C2C(如淘宝、拍拍)、C2B(如威客)、O2O(如美团、饿了么).对于这类问题,可以去百度上面科普一下.

[[guide-web-35]]
== 什么是 Web Service(Web 服务)？

从表面上看,Web Service 就是一个应用程序,它向外界暴露出一个能够通过 Web 进行调用的 API.这就是说,你能够用编程的方法透明的调用这个应用程序,不需
要了解它的任何细节,跟你使用的编程语言也没有关系.例如可以创建一个提供天气预报的 Web Service,那么无论你用哪种编程语言开发的应用都可以通过调用它的 API 并
传入城市信息来获得该城市的天气预报.之所以称之为 Web Service,是因为它基于 HTTP 协议传输数据,这使得运行在不同机器上的不同应用无须借助
附加的、专门的第三方软件或硬件,就可相互交换数据或集成.

补充:这里必须要提及的一个概念是 SOA(Service-Oriented Architecture,面向服务的架构),SOA 是一种思想,它将应用程序的不同功能单元通过中立的契约联系起来,独立于硬件平台、操作系统和编程语言,使得各种形式的功能单元能够更好的集成.显然,Web Service 是 SOA 的一种较好的解决方案,它更多的是一种标准,而不是一种具体的技术.

[[guide-web-36]]
== 概念解释:SOAP、WSDL、UDDI.

SOAP:简单对象访问协议(Simple Object Access Protocol),是Web Service中交换数据的一种协议规范.

* WSDL:Web 服务描述语言(Web Service Description Language),它描述了 Web 服务的公共接口.这是一个基于 XML 的关于如何与 Web 服务通讯
和使用的服务描述;也就是描述与目录中列出的 Web 服务进行交互时需要绑定的
协议和信息格式.通常采用抽象语言描述该服务支持的操作和信息,使用的时候再将实际的网络协议和信息格式绑定给该服务.
* UDDI:统一描述、发现和集成(Universal Description, Discovery and Integration),它是一个基于XML的跨平台的描述规范,可以使世界范
围内的企业在互联网上发布自己所提供的服务.简单的说,UDDI 是访问各种 WSDL 的一个门面(可以参考设计模式中的门面模式).

[TIP]
====
提示:关于 Web Service 的相关概念和知识可以在 W3CSchool 上找到相关的资料.
====

[[guide-web-37]]
== Java 规范中和 Web Service 相关的规范有哪些？

Java 规范中和 Web Service 相关的有三个:

* JAX-WS(JSR 224):这个规范是早期的基于 SOAP 的 Web Service 规范 JAX-RPC 的替代版本,它并不提供向下兼容性,因为 RPC 样式的 WSDL 以及相关的 API 已
经在 Java EE5 中被移除了.WS-MetaData 是 JAX-WS 的依赖规范,提供了基于注解配置 Web Service 和 SOAP 消息的相关 API.
* JAXM(JSR 67):定义了发送和接收消息所需的API,相当于Web Service的服务器端.
* JAX-RS(JSR 311 & JSR 339 & JSR 370):是 Java 针对 REST(Representation State Transfer) 架构风格制定的一套 Web Service 规范.

REST 是一种软件架构模式,是一种风格,它不像SOAP那样本身承载着一种消息协议, (两种风格的 Web Service 均采用了 HTTP 做传输协议,因为 HTTP 协议能穿越防火墙,Java 的远程方法调用(RMI)等是重量级协议,通常不能穿越防火墙),因此
可以将 REST 视为基于 HTTP 协议的软件架构.REST 中最重要的两个概念是资源定位和资源操作,而 HTTP 协议恰好完整的提供了这两个点.HTTP 协议中的 URI 可以完成资源定位,而 GET、POST、OPTION、DELETE 方法可以完成资源操作
。因此 REST 完全依赖 HTTP 协议就可以完成 Web Service,而不像 SOAP 协议那样只利用了 HTTP 的传输特性，定位和操作都是由 SOAP 协议自身完成的，也
正是由于 SOAP 消息的存在使得基于 SOAP 的 Web Service 显得笨重而逐渐被淘汰.

[[guide-web-38]]
== 介绍一下你了解的 Java 领域的 Web Service 框架.

Java 领域的 Web Service 框架很多,包括 Axis2(Axis 的升级版本)、Jersey(RESTful 的 Web Service 框架)、CXF(XFire 的延续版本)、Hessian、Turmeric、JBoss SOA 等,其中绝大多数都是开源框架.

[TIP]
====
提示:面试被问到这类问题的时候一定选择自己用过的最熟悉的作答,如果之前没有了解过就应该在面试前花一些时间了解其中的两个,并比较其优缺点,这样才能在面试时给出一个漂亮的答案.
====

[[guide-web-39]]
== 转发与重定向的区别

转发:Servlet 收到请求以后不去处理请求而是去调用服务器内部的其他资源处理请求

重定向:Servlet 发送给浏览器一个特殊的响应,这个响应告诉浏览器再次向另一个地址发送请求.

[[guide-web-39-tbl]]
|===
|                | 转发   | 重定向

| 请求的次数     | 1      | 2

| 发起的位置     | 服务器 | 浏览器

| 地址栏的改变   | 不改变 | 改变

| 浏览器是否感知 | 否     | 是
|===

从数据共享上(区别):forward 是一个请求的延续,可以共享 request 作用域的数据.redirect 开启一个新的请求,不可以共享 request 作用域的数据,但可以通过 URL 方式进行数据发送.
从性能上(区别):forward 性能要高于 redirect.(因为性能上有区别,在本系统中请求跳转建议使用 forward,如果是跨域访问,建议使用 redirect.)

[[guide-web-41]]
== 如何防止表单重复提交

针对于重复提交的整体解决方案:

1. 用 redirect(重定向)来解决重复提交的问题
2. 点击一次之后,按钮失效
3. 通过 loading(Loading 原理是在点击提交时,生成 Loading 样式,在提交完成之后隐藏该样式)
4. 自定义重复提交过滤器

[[guide-web-43]]
== XML 与 JSON 对比和区别

XML

. 应用广泛,可扩展性强,被广泛应用各种场合
. 读取、解析没有JSON快
. 可读性强,可描述复杂结构

JSON

. 结构简单,都是键值对
. 读取、解析速度快,很多语言支持
. 传输数据量小,传输速率大大提高
. 描述复杂结构能力较弱

JavaScript、PHP等原生支持,简化了读取解析.成为当前互联网时代普遍应用的数据结构.