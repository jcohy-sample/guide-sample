[[web-jsp]]
= JSP

[[web-jsp-1]]
== JSP 有哪些内置对象？作用分别是什么？

JSP 有 9 个内置对象:

* request:封装客户端的请求,其中包含来自GET或POST请求的参数;
* response:封装服务器对客户端的响应;
* pageContext:通过该对象可以获取其他对象;
* session:封装用户会话的对象;
* application:封装服务器运行环境的对象;
* out:输出服务器响应的输出流对象;
* config:Web 应用的配置对象;
* page:JSP 页面本身(相当于 Java 程序中的 this);
* exception:封装页面抛出异常的对象.

补充:如果用 Servlet 来生成网页中的动态内容无疑是非常繁琐的工作,另一方面,所有的文本和 HTML 标签都是硬编码,即使做出微小的修改,都需要进行重新编译。
JSP 解决了 Servlet 的这些问题,它是 Servlet 很好的补充,可以专门用作为用户呈现视图(View),而 Servlet 作为控制器(Controller)专门负责处理用户请求并转发或重定向到某个页面。

基于 Java的Web 开发很多都同时使用了 Servlet 和 JSP.JSP 页面其实是一个 Servlet,能够运行 Servlet 的服务器(Servlet 容器)通常也是 JSP 容器,可以提供 JSP 页面的运行环境，
Tomcat 就是一个 Servlet/JSP 容器.第一次请求一个 JSP 页面时,Servlet/JSP 容器首先将 JSP 页面转换成一个 JSP 页面的实现类,这是一个实现了 JspPage 接口或其子接口 HttpJspPage 的 Java 类。
JspPage 接口是 Servlet 的子接口,因此每个 JSP 页面都是一个 Servlet.转换成功后,容器会编译 Servlet 类,之后容器加载和实例化 Java 字节码,并执行它通常对 Servlet 所做的生命周期操作。
对同一个 JSP 页面的后续请求,容器会查看这个 JSP 页面是否被修改过,如果修改过就会重新转换并重新编译并执行.如果没有则执行内存中已经存在的 Servlet 实例。
我们可以看一段 JSP 代码对应的 Java 程序就知道一切了,而且 9 个内置对象的神秘面纱也会被揭开。

JSP 页面:

[source,jsp]
----
<%@ page pageEncoding="UTF-8"%>
<%
String path = request.getContextPath();
String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";
%>
<!DOCTYPE html>
<html>
    <head>
        <base href="<%=basePath%>">
        <title>首页</title>
        <style type="text/css">
            * { font-family: "Arial"; }
        </style>
    </head>
    <body>
        <h1>Hello, World!</h1>
        <hr/>
        <h2>Current time is: <%= new java.util.Date().toString() %></h2>
    </body>
</html>
----


对应的 Java 代码:

[source,java]
----
/*
* Generated by the Jasper component of Apache Tomcat
* Version: Apache Tomcat/7.0.52
* Generated at: 2014-10-13 13:28:38 UTC
* Note: The last modified time of this file was set to
* the last modified time of the source file after
* generation to assist with modification tracking.
*/
package org.apache.jsp;
import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;
public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase
implements org.apache.jasper.runtime.JspSourceDependent {
    private static final javax.servlet.jsp.JspFactory _jspxFactory =javax.servlet.jsp.JspFactory.getDefaultFactory();
    private static java.util.Map<java.lang.String, java.lang.Long> _jspx_dependants;
    private javax.el.ExpressionFactory _el_expressionfactory;
    private org.apache.tomcat.InstanceManager _jsp_instancemanager;

    public java.util.Map<java.lang.String, java.lang.Long> getDependants() {
        return _jspx_dependants;
    }

    public void _jspInit() {
        _el_expressionfactory = _jspxFactory.getJspApplicationContext(
        getServletConfig().getServletContext()).getExpressionFactory();
        _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory
        .getInstanceManager(getServletConfig());
    }

    public void _jspDestroy() {
    }

    public void _jspService(
    final javax.servlet.http.HttpServletRequest request,
    final javax.servlet.http.HttpServletResponse response)
    throws java.io.IOException, javax.servlet.ServletException {
        // 内置对象就是在这里定义的
        final javax.servlet.jsp.PageContext pageContext;
        javax.servlet.http.HttpSession session = null;
        final javax.servlet.ServletContext application;
        final javax.servlet.ServletConfig config;
        javax.servlet.jsp.JspWriter out = null;
        final java.lang.Object page = this;
        javax.servlet.jsp.JspWriter _jspx_out = null;
        javax.servlet.jsp.PageContext _jspx_page_context = null;
        try {
            response.setContentType("text/html;charset=UTF-8");
            pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true);
            _jspx_page_context = pageContext;
            application = pageContext.getServletContext();
            config = pageContext.getServletConfig();
            session = pageContext.getSession();
            out = pageContext.getOut();
            _jspx_out = out;
            out.write('\r');
            out.write('\n');
            String path = request.getContextPath();
            String basePath = request.getScheme() + "://"
            + request.getServerName() + ":" + request.getServerPort()
            + path + "/";
            // 以下代码通过输出流将HTML标签输出到浏览器中
            out.write("\r\n");
            out.write("\r\n");
            out.write("<!DOCTYPE html>\r\n");
            out.write("<html>\r\n");
            out.write(" <head>\r\n");
            out.write(" <base href=\"");
            out.print(basePath);
            out.write("\">\r\n");
            out.write(" <title>首页</title>\r\n");
            out.write(" <style type=\"text/css\">\r\n");
            out.write(" \t* { font-family: \"Arial\"; }\r\n");
            out.write(" </style>\r\n");
            out.write(" </head>\r\n");
            out.write(" \r\n");
            out.write(" <body>\r\n");
            out.write(" <h1>Hello, World!</h1>\r\n");
            out.write(" <hr/>\r\n");
            out.write(" <h2>Current time is: ");
            out.print(new java.util.Date().toString());
            out.write("</h2>\r\n");
            out.write(" </body>\r\n");
            out.write("</html>\r\n");
        } catch (java.lang.Throwable t) {
            if (!(t instanceof javax.servlet.jsp.SkipPageException)) {
            out = _jspx_out;
            if (out != null && out.getBufferSize() != 0)
            try {
				out.clearBuffer();
            } catch (java.io.IOException e) {
            }
            if (_jspx_page_context != null)
                _jspx_page_context.handlePageException(t);
            else throw new ServletException(t);
            }
		} finally {
            _jspxFactory.releasePageContext(_jspx_page_context);
		}
    }
}
----

[[web-jsp-2]]
== 讲解 JSP 中的四种作用域.

JSP 中的四种作用域包括 page、request、 Session 和 application,具体来说:

* page 代表与一个页面相关的对象和属性.
* request代表与 Web 客户机发出的一个请求相关的对象和属性.一个请求可能跨越多个页面,涉及多个Web组件;需要在页面显示的临时数据可以置于此作用域.
* Session 代表与某个用户与服务器建立的一次会话相关的对象和属性.跟某个用户相关的数据应该放在用户自己的 Session 中.
* application 代表与整个 Web 应用程序相关的对象和属性,它实质上是跨越整个 Web 应用程序,包括多个页面、请求和会话的一个全局作用域。

[[web-jsp-3]]
== 你的项目中使用过哪些 JSTL 标签？

项目中主要使用了 JSTL 的核心标签库,包括 `<c:if>、<c:choose>、<c: when>、<c: otherwise>、<c:forEach>` 等,主要用于构造循环和分支结构以控制显示逻辑.

说明:虽然 JSTL 标签库提供了 core、sql、fmt、xml 等标签库,但是实际开发中建议只使用核心标签库(core),而且最好只使用分支和循环标签并辅以表达式语言(EL),这样才能真正做到数
据显示和业务逻辑的分离,这才是最佳实践.

[[web-jsp-4]]
== 使用标签库有什么好处？如何自定义 JSP 标签？

* 分离 JSP 页面的内容和逻辑,简化了 Web 开发;
* 开发者可以创建自定义标签来封装业务逻辑和显示逻辑;
* 标签具有很好的可移植性、可维护性和可重用性;
* 避免了对 Scriptlet(小脚本)的使用(很多公司的项目开发都不允许在 JSP 中书写小脚本)

自定义 JSP 标签包括以下几个步骤:

. 编写一个 Java 类实现实现 `Tag/BodyTag/IterationTag` 接口(开发中通常不直接实现这些接口而是继承 `TagSupport/BodyTagSupport/SimpleTagSupport` 类,这是对缺省适配模式的应用)
. 重写 `doStartTag()`、`doEndTag()` 等方法,定义标签要完成的功能
. 编写扩展名为 tld 的标签描述文件对自定义标签进行部署,`tld` 文件通常放在 `WEB-INF` 文件夹下或其子目录中

- 在 JSP 页面中使用 taglib 指令引用该标签库.


下面是一个自定义标签库的例子.

步骤1 - 标签类源代码 TimeTag.java:

[source,java]
----
package com.jackfrued.tags;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import javax.servlet.jsp.JspException;
import javax.servlet.jsp.JspWriter;
import javax.servlet.jsp.tagext.TagSupport;
public class TimeTag extends TagSupport {
    private static final long serialVersionUID = 1L;
    private String format = "yyyy-MM-dd hh:mm:ss";
    private String foreColor = "black";
    private String backColor = "white";
    public int doStartTag() throws JspException {
        SimpleDateFormat sdf = new SimpleDateFormat(format);
        JspWriter writer = pageContext.getOut();
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("<span style='color:%s;background-color:%s'>%s</span>",
                                foreColor, backColor, sdf.format(new Date())));
        try {
            writer.print(sb.toString());
        } catch(IOException e) {
            e.printStackTrace();
        }
        return SKIP_BODY;
    }
    public void setFormat(String format) {
        this.format = format;
    }
    public void setForeColor(String foreColor) {
        this.foreColor = foreColor;
    }
    public void setBackColor(String backColor) {
        this.backColor = backColor;
    }
}
----

步骤2 - 编写标签库描述文件 my.tld:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8" ?>
<taglib xmlns="http://java.sun.com/xml/ns/j2ee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
                            http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"
        version="2.0">
    <description>定义标签库</description>
    <tlib-version>1.0</tlib-version>
    <short-name>MyTag</short-name>
    <tag>
        <name>time</name>
        <tag-class>com.jackfrued.tags.TimeTag</tag-class>
        <body-content>empty</body-content>
        <attribute>
            <name>format</name>
            <required>false</required>
        </attribute>
        <attribute>
            <name>foreColor</name>
        </attribute>
        <attribute>
            <name>backColor</name>
        </attribute>
    </tag>
</taglib>
----

步骤3 - 在 JSP 页面中使用自定义标签:

[source,jsp]
----
<%@ page pageEncoding="UTF-8"%>
<%@ taglib prefix="my" uri="/WEB-INF/tld/my.tld" %>
<%
String path = request.getContextPath();
String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";
%>
<!DOCTYPE html>
<html>
    <head>
        <base href="<%=basePath%>">
        <title>首页</title>
        <style type="text/css">
            * { font-family: "Arial"; font-size:72px; }
        </style>
    </head>
    <body>
        <my:time format="yyyy-MM-dd" backColor="blue" foreColor="yellow"/>
    </body>
</html>
----

提示:如果要将自定义的标签库发布成 JAR 文件,需要将标签库描述文件(tld 文件)放在 JAR 文件的 META-INF 目录下,可以 JDK 中的 jar 工具完成 JAR 文件的生成.

[[web-jsp-5]]
== 说一下表达式语言(EL)的隐式对象及其作用

EL 的隐式对象包括:pageContext、initParam(访问上下文参数)、param(访问请求参数)、paramValues、header(访问请求头)、headerValues、 Cookie (访问 Cookie )、applicationScope(访问 application 作用域)、sessionScope(访问 session 作用域)、requestScope(访问 request 作用域)、pageScope(访问 page 作用域).

用法如下所示:

* ${pageContext.request.method}
* ${pageContext["request"]["method"]}
* ${pageContext.request["method"]}
* ${pageContext["request"].method}
* ${initParam.defaultEncoding}
* ${header["accept-language"]}
* ${headerValues["accept-language"][0]}
* ${cookie.jsessionid.value}
* ${sessionScope.loginUser.username}

补充:表达式语言的 `.` 和 `[]` 运算作用是一致的,唯一的差别在于如果访问的属性名不符合 Java 标识符命名规则,例如上面的 `accept-language` 就不是一个有效的 Java 标识符,
那么这时候就只能用 `[]` 运算符而不能使用.运算符获取它的值

[[web-jsp-6]]
== 表达式语言(EL)支持哪些运算符？


除了 `.` 和 `[]` 运算符,EL 还提供了:

* 算术运算符:+、-、*、/或div、%或mod
* 关系运算符:==或eq、!=或ne、>或gt、>=或ge、<或lt、<=或le
* 逻辑运算符:&&或and、||或or、!或not
* 条件运算符:${statement? A : B}(跟 Java 的条件运算符类似)
* empty 运算符:检查一个值是否为null或者空(数组长度为0或集合中没有元素也返回true)

[[web-jsp-7]]
== Java Web 开发的 Model 1 和 Model 2 分别指的是什么？

Model 1 是以页面为中心的 Java Web 开发,使用 JSP+JavaBean 技术将页面显示逻辑和业务逻辑处理分开,JSP 实现页面显示,JavaBean 对象用来保存数据和实现业务逻辑.Model 2 是基于
MVC(模型-视图-控制器,Model-View-Controller)架构模式的开发模型,实现了模型和视图的彻底分离,利于团队开发和代码复用,如下图所示.

image::{oss-images}/guide-3.jpg[]

[[web-jsp-8]]
== JSP 中的静态包含和动态包含有什么区别？


静态包含是通过 JSP 的 `include` 指令包含页面,动态包含是通过 JSP 标准动作 `<jsp:forward>` 包含页面.静态包含是编译时包含,如果包含的页面不存在则会产生编译错误,而且
两个页面的 "contentType" 属性应保持一致,因为两个页面会合二为一,只产生一个 class 文件,
因此被包含页面发生的变动再包含它的页面更新前不会得到更新.动态包含是运行时包含,可以向被包含的页面传递参数,包含页面和被包含页面是
独立的,会编译出两个 class 文件,如果被包含的页面不存在,不会产生编译错误,也不影响页面其他部分的执行.代码如下所示:

[source,jsp]
----
<%-- 静态包含--%>
<%@ include file="..." %>
<%-- 动态包含--%>
<jsp:include page="...">
    <jsp:param name="..." value="..." />
</jsp:include>
----

[[web-jsp-9]]
== 如何在基于 Java 的 Web 项目中实现文件上传和下载？

在 Servlet 3 以前,Servlet API 中没有支持上传功能的 API,因此要实现上传功能需要引入第三方工具从 POST 请求中获得上传的附件或者通过自行处理输入流来获得上传的文件,我们推荐使用 Apache 的 commons-fileupload 从 Servlet 3 开始,文件上传变得无比简单,相信看看下面的例子一切都清楚了.

上传页面 index.jsp:

[source,jsp]
----
<%@ page pageEncoding="utf-8"%>
<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Photo Upload</title>
    </head>
    <body>
        <h1>Select your photo and upload</h1>
        <hr/>
        <div style="color:red;font-size:14px;">${hint}</div>
        <form action="UploadServlet" method="post" enctype="multipart/form-data">
            Photo file: <input type="file" name="photo" />
            <input type="submit" value="Upload" />
        </form>
    </body>
</html>
----

支持上传的 Servlet:

[source,java]
----
package com.jackfrued.servlet;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.Part;
@WebServlet("/UploadServlet")
@MultipartConfig
public class UploadServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
    protected void doPost(HttpServletRequest request,
                          HttpServletResponse response) throws ServletException, IOException {
        // 可以用request.getPart()方法获得名为photo的上传附件
        // 也可以用request.getParts()获得所有上传附件(多文件上传)
        // 然后通过循环分别处理每一个上传的文件
        Part part = request.getPart("photo");
        if (part != null && part.getSubmittedFileName().length() > 0) {
            // 用ServletContext对象的getRealPath()方法获得上传文件夹的绝对路径
            String savePath = request.getServletContext().getRealPath("/upload");
            // Servlet 3.1规范中可以用Part对象的getSubmittedFileName()方法获得上传的文件名
            // 更好的做法是为上传的文件进行重命名(避免同名文件的相互覆盖)
            part.write(savePath + "/" + part.getSubmittedFileName());
            request.setAttribute("hint", "Upload Successfully!");
        } else {
            request.setAttribute("hint", "Upload failed!");
        }
        // 跳转回到上传页面
        request.getRequestDispatcher("index.jsp").forward(request, response);
    }
}
----

[[web-jsp-10]]
== 如何设置请求的编码以及响应内容的类型？

通过请求对象(ServletRequest)的 `setCharacterEncoding(String)` 方法可以设置请求的编码,其实要彻底解决乱码问题就应该让页面、服务器、请求和响应、Java 程序都使用统一的编码,最好的选择当然是 UTF-8;通过
响应对象(ServletResponse)的 `setContentType(String)` 方法可以设置响应内容的类型,当然也可以通过
`HttpServletResponse` 对象的 `setHeader(String, String)` 方法来设置.

说明:现在如果还有公司在面试的时候问 JSP 的声明标记、表达式标记、小脚本标记这些内容的话,这样的公司也不用去了,其实 JSP 内置对象、JSP 指令这些东西基本上都可以忘却了,关于 Java Web 开发的相关知
识,可以看一下《Servlet&JSP思维导图》,上面有完整的知识点的罗列.想了解如何实现自定义 MVC 框架的,可以看一下《Java Web 自定义 MVC 框架详解》.

