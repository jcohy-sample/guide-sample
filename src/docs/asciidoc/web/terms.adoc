[[web-terms]]
= 术语概念

[[web-terms-1]]
== 什么是领域模型(domain model)？贫血模型(anaemic domain model)和充血模型(rich domain model)有什么区别？

领域模型是领域内的概念类或现实世界中对象的可视化表示,又称为概念模型或分析对象模型,它专注于分析问题领域本身,发掘重要的业务领域概念,并建立业务领域概念之间的关系。
贫血模型是指使用的领域对象中只有 setter 和 getter 方法(POJO),所有的业务逻辑都不包含在领域对象中而是放在业务逻辑层.有人将我们这里说的贫血模型进一步划分成失血模型(领域对象完全没有业务逻辑)和贫血模型(领域对象有少量的业务逻辑)，
我们这里就不对此加以区分了.充血模型将大多数业务逻辑和持久化放在领域对象中,业务逻辑(业务门面)只是完成对业务逻辑的封装、事务和权限等的处理.下面两张图分别展示了贫血模型和充血模型的分层架构.

贫血模型

image::{oss-images}/guide-7.jpg[]

充血模型

image::{oss-images}/guide-8.jpg[]

贫血模型下组织领域逻辑通常使用事务脚本模式,让每个过程对应用户可能要做的一个动作,每个动作由一个过程来驱动.也就是说在设计业务逻辑接口的时候,每个方法对应着用户的一个操作,这种模式有以下几个有点:

* 它是一个大多数开发者都能够理解的简单过程模型(适合国内的绝大多数开发者).
* 它能够与一个使用行数据入口或表数据入口的简单数据访问层很好的协作.
* 事务边界的显而易见,一个事务开始于脚本的开始,终止于脚本的结束,很容易通过代理(或 切面)实现声明式事务.

然而,事务脚本模式的缺点也是很多的,随着领域逻辑复杂性的增加,系统的复杂性将迅速增加,程序结构将变得极度混乱.开源中国社区上有一篇很好的译文《贫血领域模型是如何导致糟糕的软件产生》对这个问题做了比较细致的阐述.

[[web-terms-2]]
== 谈一谈测试驱动开发(TDD)的好处以及你的理解.

TDD是指在编写真正的功能实现代码之前先写测试代码,然后根据需要重构实现代码.在JUnit的作者Kent Beck的大作《测试驱动开发:实战与模式解析》(Test-Driven Development: by Example)一书中有这么一段内容:“消除恐惧和不确定性是编写测试驱动代码的重要原因”.因为编写代码时的恐惧会让你小心试探,让你回避沟通,让你羞于得到反馈,让你变得焦躁不安,而TDD是消除恐惧、让Java开发者更加自信更加乐于沟通的重要手段.TDD会带来的好处可能不会马上呈现,但是你在某个时候一定会发现,这些好处包括:

* 更清晰的代码 ? 只写需要的代码
* 更好的设计
* 更出色的灵活性 ? 鼓励程序员面向接口编程
* 更快速的反馈 ? 不会到系统上线时才知道bug的存在

补充:敏捷软件开发的概念已经有很多年了,而且也部分的改变了软件开发这个行业,TDD也是敏捷开发所倡导的.
TDD 可以在多个层级上应用,包括单元测试(测试一个类中的代码)、集成测试(测试类之间的交互)、系统测试(测试运行的系统)和系统集成测试(测试运行的系统包括使用的第三方组件).TDD的实施步骤是:红(失败测试)- 绿(通过测试) * 重构.关于实施TDD的详细步骤请参考另一篇文章《测试驱动开发之初窥门径》.在使用TDD开发时,经常会遇到需要被测对象需要依赖其他子系统的情况,但是你希望将测试代码跟依赖项隔离,以保证测试代码仅仅针对当前被测对象或方法展开,这时候你需要的是测试替身.测试替身可以分为四类:

* 虚设替身:只传递但是不会使用到的对象,一般用于填充方法的参数列表
* 存根替身:总是返回相同的预设响应,其中可能包括一些虚设状态
* 伪装替身:可以取代真实版本的可用版本(比真实版本还是会差很多)
* 模拟替身:可以表示一系列期望值的对象,并且可以提供预设响应

Java 世界中实现模拟替身的第三方工具非常多,包括 `EasyMock`、`Mockito`、`jMock` 等.

[[web-terms-3]]
== 事务的 ACID 是指什么？

* 原子性(Atomic):事务中各项操作,要么全做要么全不做,任何一项操作的失败都会导致整个事务的失败
* 一致性(Consistent):事务结束后系统状态是一致的;
* 隔离性(Isolated):并发执行的事务彼此无法看到对方的中间状态;
* 持久性(Durable):事务完成后所做的改动都会被持久化,即使发生灾难性的失败.通过日志和同步备份可以在故障发生后重建数据.

补充:关于事务,在面试中被问到的概率是很高的,可以问的问题也是很多的.首先需要知道的是,只有存在并发数据访问时才需要事务.当多个事务访问同一数据时,可能会存在 5 类问题,包括 3 类数据读取问题(脏读、不可重复读和幻读)和 2 类数据更新问题(第 1 类丢失更新和第 2 类丢失更新).

* 脏读(Dirty Read):A 事务读取 B 事务尚未提交的数据并在此基础上操作,而B事务执行回滚,那么 A 读取到的数据就是脏数据.

[[web-terms-3-tbl]]
.脏读
|===
| 时间 | 转账事务A                   | 取款事务B

| T1   |                             | 开始事务

| T2   | 开始事务                    |

| T3   |                             | 查询账户余额为1000元

| T4   |                             | 取出500元余额修改为500元

| T5   | 查询账户余额为500元(脏读) |

| T6   |                            | 撤销事务余额恢复为1000元

| T7   | 汇入100元把余额修改为600元 |

| T8   | 提交事务                   |
|===

* 不可重复读(Unrepeatable Read):事务 A 重新读取前面读取过的数据,发现该数据已经被另一个已提交的事务 B 修改过了.

[[web-terms-3-2-tbl]]
.不可重复读
|===
| 时间 | 转账事务A                   | 取款事务B

| T1   |                             | 开始事务

| T2   | 开始事务                    |

| T3   |                             | 查询账户余额为1000元

| T4   |       查询账户余额为1000元                      |

| T5   |  |        取出100元修改余额为900元

| T6   |  |        提交事务

| T7   | 查询账户余额为900元(不可重复读) |
|===

* 幻读(Phantom Read):事务 A 重新执行一个查询,返回一系列符合查询条件的行,发现其中插入了被事务 B 提交的行.
** 第1类丢失更新:事务 A 撤销时,把已经提交的事务 B 的更新数据覆盖了.
+
[[web-terms-3-3-tbl]]
|===
| 时间 | 统计金额事务A                   | 转账事务B

| T1   |                             | 开始事务

| T2   | 开始事务                    |

| T3   |  统计总存款为 10000 元                           |

| T4   |                         | 新增一个存款账户存入 100 元

| T5   |  |        提交事务

| T6   |  |       再次统计总存款为 10100 元(幻读)
|===

* 第2类丢失更新:事务 A 覆盖事务 B 已经提交的数据,造成事务 B 所做的操作丢失.

[[web-terms-3-4-tbl]]
|===
| 时间 | 转账事务A              | 取款事务B

| T1   |                             |     开始事务

| T2   |       开始事务              |

| T3   |                             | 查询账户余额为 1000 元

| T4   |         查询账户余额为 1000 元                |

| T5   |  |        取出 100 元将余额修改为 900 元

| T6   |  |       提交事务

| T7   |  汇入 100 元将余额修改为 1100 元|

| T8   |  提交事务|

| T9   |  查询账户余额为 1100 元(丢失更新)|
|===

数据并发访问所产生的问题,在有些场景下可能是允许的,但是有些场景下可能就是致命的,数据库通常会通过锁机制来解决数据并发访问问题,按锁定对象不同可以分为表级锁和行级锁。
按并发事务锁定关系可以分为共享锁和独占锁,具体的内容大家可以自行查阅资料进行了解.直接使用锁是非常麻烦的,为此数据库为用户提供了自动锁机制,只要用户指定会话的事务隔离级别，
数据库就会通过分析 SQL 语句然后为事务访问的资源加上合适的锁,此外,数据库还会维护这些锁通过各种手段提高系统的性能,这些对用户来说都是透明的(就是说你不用理解,事实上我确实也不知道)。
ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别,如下表所示:

[[web-terms-3-5-tbl]]
|===
| 隔离级别        | 脏读   | 不可重复读 | 幻读   | 第一类丢失更新 | 第二类丢失更新

| READ UNCOMMITED | 允许   | 允许       | 允许   | 不允许         | 允许

| READ COMMITTED  | 不允许 | 允许       | 允许   | 不允许         | 允许

| REPEATABLE READ | 不允许 | 不允许     | 允许   | 不允许         | 不允许

| SERIALIZABLE    | 不允许 | 不允许     | 不允许 |                | 不允许
|===

需要说明的是,事务隔离级别和数据访问的并发性是对立的,事务隔离级别越高并发性就越差.所以要根据具体的应用来确定合适的事务隔离级别,这个地方没有万能的原则.

== Http 常见的状态码有哪些？

* 200 OK //客户端请求成功
* 301 Moved Permanently（永久移除)，请求的 URL 已移走。Response 中应该包含一个 Location URL, 说明资源现在所处的位置
* 302 found 重定向
* 400 Bad Request //客户端请求有语法错误，不能被服务器所理解
* 401 Unauthorized //请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用
* 403 Forbidden //服务器收到请求，但是拒绝提供服务
* 404 Not Found //请求资源不存在，eg：输入了错误的 URL
* 500 Internal Server Error //服务器发生不可预期的错误
* 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常

[[web-terms-4]]
== GET 和 POST 请求的区别？

* GET 请求的数据会附在 URL 之后（就是把数据放置在 HTTP 协议头中），以?分割 URL 和传输数据，参数
之间以&相连，如：login.action?name=zhagnsan&password=123456。POST 把提交的数据则放置在是 HTTP 包的包
体中。
* GET 方式提交的数据最多只能是 1024 字节，理论上 POST 没有限制，可传较大量的数据。其实这样说是错
误的，不准确的：“GET 方式提交的数据最多只能是 1024 字节"，因为 GET 是通过 URL 提交数据，那么 GET 可
提交的数据量就跟 URL 的长度有直接关系了。而实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对
URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。 IE 对 URL 长度的限制是 2083 字节(2K+35)。
对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。
* POST 的安全性要比 GET 的安全性高。注意：这里所说的安全性和上面 GET 提到的“安全”不是同个概念。
上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的 Security 的含义，比如：通过 GET 提交数据，用户名和密码将明文出现在 URL 上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，
那么别人就可以拿到你的账号和密码了，除此之外，使用 GET 提交数据还可能会造成 Cross-site request forgery 攻
击。
* Get 是向服务器发索取数据的一种请求，而 Post 是向服务器提交数据的一种请求，在 FORM（表单）中，Method 默认为"GET"，实质上，GET 和 POST 只是发送机制不同，并不是一个取一个发！

[[web-terms-5]]
== Cookie 和 Session 的区别

. Session 是存储在服务器端, Cookie 是存储在客户端的,所以从安全来讲 Session 的安全性要比 Cookie 高.
. 单个 Cookie 保存的数据不能超过 `4K`,很多浏览器都限制一个站点最多保存 20 个 Cookie ,而 Session  Session 是存放在服务器的内存中,所以 Session 里的东西不断增加会造成服务器的负担,所以一般把很重要的信息才存储在 Session 中,而把一些次要东西存储在客户端的 Cookie 里(例如将登陆信息等重要信息存放为 Session ,其他信息如果需要保留,可以放在 Cookie )
*  Cookie 分为两大类分为会话 Cookie 和持久化 Cookie ,会话 Cookie ,存放在客户端浏览器的内存中,他的生命周期和浏览器是一致的,浏览器关了会话 Cookie 也就消失了,而持久化 Cookie 是存放在客户端硬盘中,而持久化 Cookie 的生命周期就是我们在设置 Cookie 时候设置的那个保存时间
* 当浏览器关闭时 Session 会不会丢失, Session 的信息是通过会话 Cookie 的 Session id获取的,当浏览器关闭的时候会话 Cookie 消失,所以我们的 Session id也就消失了,但是 Session 的信息还存在服务器端,这时我们只是查不到所谓的 Session 但它并不是不存在.
*  Session 在什么情况下丢失,就是在服务器关闭的时候(也可以说说 Session 的活化和钝化),或者是 Session 过期(默认时间是 30 分钟),再或者调用了 `invalidate()` 的或者是我们想要 Session 中的某一条数据消失调用 ``Session.removeAttribute()``方法
*  Session 在什么时候被创建呢,确切的说是通过调用 getSession() 来创建.访问 HTML 页面是不会创建  Session  ,但是访问index.JSP时会创建 Session (JSP 实际上是一个 Servlet,Servlet 中有 getSession 方法).

[[web-terms-6]]
== 常用的 Web 服务器有哪些？

Unix 和 Linux 平台下使用最广泛的免费 HTTP 服务器是 Apache 服务器,而 Windows 平台的服务器通常使用 IIS 作为 Web 服务器。
选择 Web 服务器应考虑的因素有:性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等.下面是对常见服务器的简介:

* IIS:Microsoft 的 Web 服务器产品,全称是Internet Information Services.IIS是允许在公共 Intranet 或 Internet 上发布信息的 Web 服务器。IIS 是目前最流行的Web服务器产品之一,很多著名的网站都是建立在 IIS 的平台上。
IIS 提供了一个图形界面的管理工具,称为 Internet 服务管理器,可用于监视配置和控制 Internet 服务。
IIS 是一种 Web 服务组件,其中包括 Web 服务器、FTP 服务器、NNTP 服务器和 SMTP 服务器,分别用于网页浏览、文件传输、新闻服务和邮件发送等方面,它使得在网络(包括互联网和局域网)上发布信息成了一件很容易的事。
它提供 ISAPI(Intranet Server API)作为扩展Web服务器功能的编程接口;同时,它还提供一个 Internet 数据库连接器,可以实现对数据库的查询和更新.
* Kangle:Kangle Web 服务器是一款跨平台、功能强大、安全稳定、易操作的高性能 Web 服务器和反向代理服务器软件.此外,Kangle 也是一款专为做虚拟主机研发的Web服务器.实现虚拟主机独立进程、独立
身份运行.用户之间安全隔离,一个用户出问题不影响其他用户.支持 PHP、ASP、ASP.NET、Java、Ruby 等多种动态开发语言.
* WebSphere:WebSphere Application Server 是功能完善、开放的 Web 应用程序服务器,是IBM电子商务计划的核心部分,它是基于 Java 的应用环境,用于建立、部署和管理 Internet 和 Intranet Web 应用程序,
适应各种 Web 应用程序服务器的需要.
* WebLogic:WebLogic Server 是一款多功能、基于标准的Web应用服务器,为企业构建企业应用提供了坚实的基础.针对各种应用开发、关键性任务的部署,各种系统和数据库的集成、跨 Internet 协作等 Weblogic 都提
供了相应的支持.由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发等优势,很多公司的企业级应用都选择它来作为开发和部署的环境.WebLogic Server 在使应用服务器成为企业应用
架构的基础方面一直处于领先地位,为构建集成化的企业级应用提供了稳固的基础.
* Apache:目前 Apache 仍然是世界上用得最多的 Web 服务器,其市场占有率很长时间都保持在 60% 以上(目前的市场份额约40%左右).世界上很多著名的网站都是 Apache 的产物,它的成功之处主要在
于它的源代码开放、有一支强大的开发团队、支持跨平台的应用(可以运行在几乎所有的 Unix、Windows、Linux 系统平台上)以及它的可移植性等方面.
* Tomcat:Tomcat 是一个开放源代码、运行 Servlet 和 JSP 的容器.Tomcat 实现了 Servlet 和 JSP 规范.此外,Tomcat 还实现了 Apache-Jakarta 规范而且比绝大多数商业应用软件服务器要好,因此目前也有不少的 Web 服务器都选择了 Tomcat.
* Nginx:读作 "engine x",是一个高性能的 HTTP 和反向代理服务器,也是一个 IMAP/POP3/SMTP 代理服务器.Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler 站点开发的,第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日.其将源代码以类 BSD 许可证的形式发布,因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。
在 2014 年 下半年,Nginx 的市场份额达到了 14%.

[[web-terms-7]]
== 实现会话跟踪的技术有哪些

由于 HTTP 协议本身是无状态的,服务器为了区分不同的用户,就需要对用户会话进行跟踪,简单的说就是为用户进行登记,为用户分配唯一的ID,下一次用户在请求中包含此ID,服务器据此判断到底是哪一个用户.

* URL 重写:在 URL 中添加用户会话的信息作为请求的参数,或者将唯一的会话 ID 添加到 URL 结尾以标识一个会话.
* 设置表单隐藏域:将和会话跟踪相关的字段添加到隐式表单域中,这些信息不会在浏览器中显示但是提交表单时会提交给服务器.这两种方式很难处理跨越多个页面的信息传递,因为如果每次都要修改 URL 或在页面中添加隐
式表单域来存储用户会话相关信息,事情将变得非常麻烦.
* cookie: Cookie 有两种,一种是基于窗口的,浏览器窗口关闭后, Cookie 就没有了;另一种是将信息存储在一个临时文件中,并设置存在的时间.当用户通过浏览器和服务器建立一次会话后,会话 ID 就会随响应
信息返回存储在基于窗口的 Cookie 中,那就意味着只要浏览器没有关闭,会话没
有超时,下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份.会话中可以为用户保存信息.会话对象是在服务器内存中的,而基于窗口的 Cookie 是在客户端内存中的.如果浏览器禁用了cookie,那么就需要
通过下面两种方式进行会话跟踪.当然,在使用 Cookie 时要注意几点:首先不要在 Cookie 中存放敏感信息;其次 Cookie 存储的数据量有限(4k),不能将过多的内容存储 Cookie 中;再者浏览器通常只允许
一个站点最多存放 20 个 Cookie .当然,和用户会话相关的其他信息(除了会话ID)也可以存在 Cookie 方便进行会话跟踪.
* HttpSession:在所有会话跟踪技术中,HttpSession 对象是最强大也是功能最多的.当一个用户第一次访问某个网站时会自动创建 HttpSession,每个用户可以访问他自己的 HttpSession.可以通
过 HttpServletRequest 对象的 getSession 方法获得 HttpSession,通过 HttpSession 的 setAttribute 方法可以将一个值放在 HttpSession 中,通过调用 HttpSession 对象的 getAttribute 方法,同
时传入属性名就可以获取保存在 HttpSession 中的对象.与上面三种方式不同的是,HttpSession 放在服务器的内存中,因此不要将过大的对象放在里面,即使目前的 Servlet 容器可以在内存将满时将 HttpSession 中的
对象移到其他存储设备中,但是这样势必影响性能.添加到 HttpSession 中的值可以是任意 Java 对象,这个对象最好实现了 Serializable 接口,这样 Servlet 容器在必要的时候可以将其序列化
到文件中,否则在序列化时就会出现异常.

**补充:** HTML5 中可以使用 WebStorage 技术通过 JavaScript 来保存数据,例如可以使用 localStorage 和 sessionStorage 来保存用户会话的信息,也能够实现会话跟踪

[[web-terms-8]]
== 解释一下网络应用的模式及其特点.

典型的网络应用模式大致有三类:B/S、C/S、P2P.其中B代表浏览器(Browser)、C代表客户端(Client)、S代表服务器(Server),P2P 是对等模式,不区分客户端和服务器.
B/S应用模式中可以视为特殊的 C/S 应用模式,只是将 C/S 应用模式中的特殊的客户端换成了浏览器,因为几乎所有的系统上都有浏览器,那么只要打开浏览器就可以使用应用,没
有安装、配置、升级客户端所带来的各种开销.P2P应用模式中,成千上万台彼此连接的计算机都处于对等的地位,整个网络一般来说不依赖专用的集中服务器.网络中的每
一台计算机既能充当网络服务的请求者,又对其它计算机的请求作出响应,提供资源和服务.通常这些资源和服务包括:信息的共享和交换、计算资源(如 CPU 的共享)、存储
共享(如缓存和磁盘空间的使用)等,这种应用模式最大的阻力安全性、版本等问题,目前有很多应用都混合使用了多种应用模型,最常见的网络视频应用,它几乎把三种模式都用上了.

补充:此题要跟"电子商务模式"区分开,因为有很多人被问到这个问题的时候马上想到的是 B2B(如阿里巴巴)、B2C(如当当、亚马逊、京东)、C2C(如淘宝、拍拍)、C2B(如威客)、O2O(如美团、饿了么).对于这类问题,可以去百度上面科普一下.

[[web-terms-9]]
== 转发与重定向的区别

转发:Servlet 收到请求以后不去处理请求而是去调用服务器内部的其他资源处理请求

重定向:Servlet 发送给浏览器一个特殊的响应,这个响应告诉浏览器再次向另一个地址发送请求.

[[web-terms-9-tbl]]
|===
|                | 转发   | 重定向

| 请求的次数     | 1      | 2

| 发起的位置     | 服务器 | 浏览器

| 地址栏的改变   | 不改变 | 改变

| 浏览器是否感知 | 否     | 是
|===

从数据共享上(区别):forward 是一个请求的延续,可以共享 request 作用域的数据.redirect 开启一个新的请求,不可以共享 request 作用域的数据,但可以通过 URL 方式进行数据发送.
从性能上(区别):forward 性能要高于 redirect.(因为性能上有区别,在本系统中请求跳转建议使用 forward,如果是跨域访问,建议使用 redirect.)

[[web-terms-10]]
== 如何防止表单重复提交

针对于重复提交的整体解决方案:

1. 用 redirect(重定向)来解决重复提交的问题
2. 点击一次之后,按钮失效
3. 通过 loading(Loading 原理是在点击提交时,生成 Loading 样式,在提交完成之后隐藏该样式)
4. 自定义重复提交过滤器